/*******************************************************************************
 * GameCrowdDestinationQueuePoint generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2015 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class GameCrowdDestinationQueuePoint extends GameCrowdInteractionPoint
    native
    placeable
    hidecategories(Navigation,Advanced,Collision,Display,Actor,Movement,Physics);

/** Position behind this one in line */
var() GameCrowdDestinationQueuePoint NextQueuePosition;
var GameCrowdInteractionPoint PreviousQueuePosition;
var GameCrowdAgent QueuedAgent;
var transient GameCrowdDestination QueueDestination;
var bool bClearingQueue;
var bool bPendingAdvance;
/** Average pause time before agent reacts to queue movement */
var() float AverageReactionTime;
var class<GameCrowdBehavior_WaitInQueue> QueueBehaviorClass;

// Export UGameCrowdDestinationQueuePoint::execQueueReachedBy(FFrame&, void* const)
native function bool QueueReachedBy(GameCrowdAgent Agent, Vector TestPosition);

simulated function bool HasSpace()
{
    // End:0x6E
    if((QueuedAgent == none) && ((NextQueuePosition == none) || !NextQueuePosition.bPendingAdvance) || NextQueuePosition.QueuedAgent == none)
    {
        return true;
    }
    // End:0x7F
    if(NextQueuePosition == none)
    {
        return false;
    }
    return NextQueuePosition.HasSpace();
    //return ReturnValue;    
}

simulated event ReachedDestination(GameCrowdAgent Agent)
{
    local GameCrowdDestinationQueuePoint QueuePoint;

    QueuePoint = Agent.CurrentDestination.QueueHead;
    J0x3D:
    // End:0x2F2 [Loop If]
    if(QueuePoint != none)
    {
        // End:0x2C7
        if(QueuePoint.NextQueuePosition == self)
        {
            // End:0xCB
            if(QueuePoint.QueuedAgent == none)
            {
                WarnInternal((string(Agent) $ "in queue behind empty spot at ") $ string(self));
            }
            // End:0x2C7
            else
            {
                // End:0x2C7
                if(!QueuePoint.QueueReachedBy(QueuePoint.QueuedAgent, QueuePoint.QueuedAgent.Location) && VSizeSq(QueuePoint.Location - Agent.Location) < VSizeSq(QueuePoint.Location - QueuePoint.QueuedAgent.Location))
                {
                    QueuedAgent = QueuePoint.QueuedAgent;
                    QueuePoint.QueuedAgent = Agent;
                    GameCrowdBehavior_WaitInQueue(QueuedAgent.CurrentBehavior).QueuePosition = self;
                    GameCrowdBehavior_WaitInQueue(QueuePoint.QueuedAgent.CurrentBehavior).QueuePosition = QueuePoint;
                    return;
                }
            }
        }
        QueuePoint = QueuePoint.NextQueuePosition;
        // [Loop Continue]
        goto J0x3D;
    }
    GameCrowdBehavior_WaitInQueue(QueuedAgent.CurrentBehavior).bIdleBehavior = true;
    QueuedAgent.PlayIdleAnimation();
    //return;    
}

simulated function AdvanceCustomerTo(GameCrowdInteractionPoint FrontPosition)
{
    PreviousQueuePosition = FrontPosition;
    bPendingAdvance = true;
    SetTimer(AverageReactionTime, false, 'ActuallyAdvance');
    //return;    
}

private final simulated function ActuallyAdvance()
{
    local GameCrowdDestinationQueuePoint FrontQueuePosition;
    local GameCrowdDestination QueueFront;
    local GameCrowdAgent TempAgent;

    bPendingAdvance = false;
    // End:0x1D2
    if(QueuedAgent != none)
    {
        TempAgent = QueuedAgent;
        bClearingQueue = true;
        QueuedAgent.StopBehavior();
        bClearingQueue = false;
        QueuedAgent = none;
        FrontQueuePosition = GameCrowdDestinationQueuePoint(PreviousQueuePosition);
        // End:0xC7
        if(FrontQueuePosition != none)
        {
            FrontQueuePosition.AddCustomer(TempAgent, none);
        }
        // End:0x146
        else
        {
            QueueFront = GameCrowdDestination(PreviousQueuePosition);
            // End:0x11E
            if(QueueFront == none)
            {
                WarnInternal("Illegal front position for queue " $ string(self));
                return;
            }
            QueueFront.IncrementCustomerCount(TempAgent);
        }
        // End:0x1A3
        if(QueuedAgent != none)
        {
            WarnInternal((((string(self) $ " GOT QUEUED AGENT BACK - Head ") $ string(PreviousQueuePosition)) $ " Tail ") $ string(NextQueuePosition));
        }
        // End:0x1D2
        else
        {
            // End:0x1D2
            if(NextQueuePosition != none)
            {
                NextQueuePosition.AdvanceCustomerTo(self);
            }
        }
    }
    //return;    
}

simulated function AddCustomer(GameCrowdAgent NewCustomer, GameCrowdInteractionPoint PreviousPosition)
{
    // End:0x22
    if(PreviousPosition != none)
    {
        PreviousQueuePosition = PreviousPosition;
    }
    // End:0x100
    if(QueuedAgent == none)
    {
        QueuedAgent = NewCustomer;
        NewCustomer.ActivateInstancedBehavior(new (NewCustomer) QueueBehaviorClass);
        GameCrowdBehavior_WaitInQueue(NewCustomer.CurrentBehavior).QueuePosition = self;
        GameCrowdBehavior_WaitInQueue(NewCustomer.CurrentBehavior).ActionTarget = PreviousQueuePosition;
    }
    // End:0x184
    else
    {
        // End:0x13B
        if(NextQueuePosition != none)
        {
            NextQueuePosition.AddCustomer(NewCustomer, self);
        }
        // End:0x184
        else
        {
            WarnInternal(((string(self) $ " Attempted to add customer ") $ string(NewCustomer)) $ " beyond end of queue");
        }
    }
    //return;    
}

simulated function ClearQueue(GameCrowdAgent OldCustomer)
{
    // End:0xF2
    if(!bClearingQueue)
    {
        bClearingQueue = true;
        // End:0x8E
        if(OldCustomer == QueuedAgent)
        {
            QueuedAgent.StopBehavior();
            QueuedAgent = none;
            // End:0x8B
            if(NextQueuePosition != none)
            {
                NextQueuePosition.AdvanceCustomerTo(self);
            }
        }
        // End:0xE6
        else
        {
            WarnInternal((("Attempted to clear " $ string(OldCustomer)) $ " from queue position with customer ") $ string(QueuedAgent));
        }
        bClearingQueue = false;
    }
    //return;    
}

simulated function bool HasCustomer()
{
    return QueuedAgent != none;
    //return ReturnValue;    
}

defaultproperties
{
    AverageReactionTime=0.70
    QueueBehaviorClass=class'GameCrowdBehavior_WaitInQueue'
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionRadius=100.0
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__GameCrowdDestinationQueuePoint.CollisionCylinder'
    CylinderComponent=CollisionCylinder
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionRadius=100.0
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__GameCrowdDestinationQueuePoint.CollisionCylinder'
    Components(0)=CollisionCylinder
    begin object name=Sprite class=SpriteComponent
        ReplacementPrimitive=none
    object end
    // Reference: SpriteComponent'Default__GameCrowdDestinationQueuePoint.Sprite'
    Components(1)=Sprite
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionRadius=100.0
        ReplacementPrimitive=none
    object end
    // Reference: CylinderComponent'Default__GameCrowdDestinationQueuePoint.CollisionCylinder'
    CollisionComponent=CollisionCylinder
}