/*******************************************************************************
 * Teleporter generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2015 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class Teleporter extends NavigationPoint
    native
    placeable
    hidecategories(Navigation,Lighting,LightColor,Force);

/** ----------------------------------------------------------------------------- Teleporter URL can be one of the following forms: TeleporterName            Teleports to a named teleporter in this level.          if none, acts only as a teleporter destination LevelName/TeleporterName     Teleports to a different level on this server. Unreal:Server.domain.com/LevelName/TeleporterName     Teleports to a different server on the net. */
var() string URL;
/** ----------------------------------------------------------------------------- Product the user must have installed in order to enter the teleporter. */
var() name ProductRequired;
/** ----------------------------------------------------------------------------- Teleporter destination flags. */
var() bool bChangesVelocity;
/** Sets yaw to teleporter's Rotation.Yaw */
var() bool bChangesYaw;
/** Reverses X-component of velocity. */
var() bool bReversesX;
/** Reverses Y-component of velocity. */
var() bool bReversesY;
/** Reverses Z-component of velocity. Teleporter flags */
var() bool bReversesZ;
/** whether this Teleporter works on vehicles */
var() bool bEnabled;
var() bool bCanTeleportVehicles;
/** ----------------------------------------------------------------------------- Teleporter destination directions. */
var() Vector TargetVelocity;
var float LastFired;

replication
{
    // Pos:0x000
    if(Role == ROLE_Authority)
        URL, bEnabled

    // Pos:0x011
    if(bNetInitial && Role == ROLE_Authority)
        TargetVelocity, bChangesVelocity, 
        bChangesYaw, bReversesX, 
        bReversesY, bReversesZ
}

// Export UTeleporter::execCanTeleport(FFrame&, void* const)
native function bool CanTeleport(Actor A);

event PostBeginPlay()
{
    // End:0x16
    if(URL ~= "")
    {
        SetCollision(false, false);
    }
    super(Actor).PostBeginPlay();
    //return;    
}

simulated event bool Accept(Actor Incoming, Actor Source)
{
    local Rotator NewRot, oldRot;
    local float Mag;
    local Vector oldDir;
    local Controller C;

    // End:0x11
    if(Incoming == none)
    {
        return false;
    }
    Disable('Touch');
    NewRot = Incoming.Rotation;
    // End:0x14A
    if(bChangesYaw)
    {
        oldRot = Incoming.Rotation;
        NewRot.Yaw = Rotation.Yaw;
        // End:0x14A
        if(Source != none)
        {
            NewRot.Yaw += ((32768 + Incoming.Rotation.Yaw) - Source.Rotation.Yaw);
        }
    }
    // End:0x454
    if(Pawn(Incoming) != none)
    {
        // End:0x1F7
        if(Role == ROLE_Authority)
        {
            // End:0x1F6
            foreach WorldInfo.AllControllers(class'Controller', C)
            {
                // End:0x1F5
                if(C.Enemy == Incoming)
                {
                    C.EnemyJustTeleported();
                }                
            }            
        }
        // End:0x254
        if(!Pawn(Incoming).SetLocation(Location))
        {
            LogInternal((string(self) $ " Teleport failed for ") $ string(Incoming));
            return false;
        }
        // End:0x36F
        if((Role == ROLE_Authority) || (WorldInfo.TimeSeconds - LastFired) > 0.50)
        {
            NewRot.Roll = 0;
            Pawn(Incoming).SetRotation(NewRot);
            Pawn(Incoming).SetViewRotation(NewRot);
            Pawn(Incoming).ClientSetRotation(NewRot);
            LastFired = WorldInfo.TimeSeconds;
        }
        // End:0x430
        if(Pawn(Incoming).Controller != none)
        {
            Pawn(Incoming).Controller.MoveTimer = -1.0;
            Pawn(Incoming).SetAnchor(self);
            Pawn(Incoming).SetMoveTarget(self);
        }
        Incoming.PlayTeleportEffect(false, true);
    }
    // End:0x4B5
    else
    {
        // End:0x487
        if(!Incoming.SetLocation(Location))
        {
            Enable('Touch');
            return false;
        }
        // End:0x4B5
        if(bChangesYaw)
        {
            Incoming.SetRotation(NewRot);
        }
    }
    Enable('Touch');
    // End:0x4F8
    if(bChangesVelocity)
    {
        Incoming.Velocity = TargetVelocity;
    }
    // End:0x6E3
    else
    {
        // End:0x614
        if(bChangesYaw)
        {
            // End:0x54C
            if(Incoming.Physics == 1)
            {
                oldRot.Pitch = 0;
            }
            oldDir = vector(oldRot);
            Mag = Incoming.Velocity Dot oldDir;
            Incoming.Velocity = (Incoming.Velocity - (Mag * oldDir)) + (Mag * vector(Incoming.Rotation));
        }
        // End:0x659
        if(bReversesX)
        {
            Incoming.Velocity.X *= -1.0;
        }
        // End:0x69E
        if(bReversesY)
        {
            Incoming.Velocity.Y *= -1.0;
        }
        // End:0x6E3
        if(bReversesZ)
        {
            Incoming.Velocity.Z *= -1.0;
        }
    }
    Incoming.PostTeleport(self);
    return true;
    //return ReturnValue;    
}

event Touch(Actor Other, PrimitiveComponent OtherComp, Vector HitLocation, Vector HitNormal)
{
    // End:0x22
    if(!bEnabled || Other == none)
    {
        return;
    }
    // End:0xA7
    if((CanTeleport(Other)) && !Other.PreTeleport(self))
    {
        PendingTouch = Other.PendingTouch;
        Other.PendingTouch = self;
    }
    //return;    
}

simulated event PostTouch(Actor Other)
{
    local Teleporter D, Dest;
    local int I;

    // End:0xFC
    if((InStr(URL, "/") >= 0) || InStr(URL, "#") >= 0)
    {
        // End:0xF9
        if(((Role == ROLE_Authority) && Pawn(Other) != none) && Pawn(Other).IsHumanControlled())
        {
            WorldInfo.Game.SendPlayer(PlayerController(Pawn(Other).Controller), URL);
        }
    }
    // End:0x236
    else
    {
        // End:0x190
        foreach AllActors(class'Teleporter', D)
        {
            // End:0x18F
            if((string(D.Tag) ~= URL) && D != self)
            {
                Dest[I] = D;
                ++ I;
                // End:0x18F
                if(I > 16)
                {
                    // End:0x190
                    break;
                }
            }            
        }        
        I = Rand(I);
        // End:0x236
        if(Dest[I] != none)
        {
            // End:0x203
            if(Other.IsA('Pawn'))
            {
                Other.PlayTeleportEffect(true, true);
            }
            Dest[I].Accept(Other, self);
        }
    }
    //return;    
}

event Actor SpecialHandling(Pawn Other)
{
    // End:0x116
    if(((bEnabled && Other.Controller.RouteCache.Length > 1) && Teleporter(Other.Controller.RouteCache[1]) != none) && string(Other.Controller.RouteCache[1].Tag) ~= URL)
    {
        // End:0x114
        if(IsOverlapping(Other))
        {
            PostTouch(Other);
        }
        return self;
    }
    return none;
    //return ReturnValue;    
}

defaultproperties
{
    bChangesYaw=true
    bEnabled=true
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionHeight=80.0
        CollisionRadius=40.0
        ReplacementPrimitive=none
        CollideActors=true
    object end
    // Reference: CylinderComponent'Default__Teleporter.CollisionCylinder'
    CylinderComponent=CollisionCylinder
    begin object name=Sprite class=SpriteComponent
        Sprite=Texture2D'EditorResources.S_Teleport'
        ReplacementPrimitive=none
    object end
    // Reference: SpriteComponent'Default__Teleporter.Sprite'
    GoodSprite=Sprite
    begin object name=Sprite2 class=SpriteComponent
        ReplacementPrimitive=none
    object end
    // Reference: SpriteComponent'Default__Teleporter.Sprite2'
    BadSprite=Sprite2
    begin object name=Sprite class=SpriteComponent
        Sprite=Texture2D'EditorResources.S_Teleport'
        ReplacementPrimitive=none
    object end
    // Reference: SpriteComponent'Default__Teleporter.Sprite'
    Components(0)=Sprite
    begin object name=Sprite2 class=SpriteComponent
        ReplacementPrimitive=none
    object end
    // Reference: SpriteComponent'Default__Teleporter.Sprite2'
    Components(1)=Sprite2
    begin object name=Arrow class=ArrowComponent
        ReplacementPrimitive=none
    object end
    // Reference: ArrowComponent'Default__Teleporter.Arrow'
    Components(2)=Arrow
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionHeight=80.0
        CollisionRadius=40.0
        ReplacementPrimitive=none
        CollideActors=true
    object end
    // Reference: CylinderComponent'Default__Teleporter.CollisionCylinder'
    Components(3)=CollisionCylinder
    begin object name=PathRenderer class=PathRenderingComponent
        ReplacementPrimitive=none
    object end
    // Reference: PathRenderingComponent'Default__Teleporter.PathRenderer'
    Components(4)=PathRenderer
    RemoteRole=ENetRole.ROLE_SimulatedProxy
    bCollideActors=true
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionHeight=80.0
        CollisionRadius=40.0
        ReplacementPrimitive=none
        CollideActors=true
    object end
    // Reference: CylinderComponent'Default__Teleporter.CollisionCylinder'
    CollisionComponent=CollisionCylinder
}