/*******************************************************************************
 * PickupFactory generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2015 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class PickupFactory extends NavigationPoint
    abstract
    native
    nativereplication
    placeable
    hidecategories(Navigation,Lighting,LightColor,Force)
    classgroup(Pickups);

var bool bOnlyReplicateHidden;
var repnotify bool bPickupHidden;
var bool bPredictRespawns;
var bool bIsSuperItem;
var bool bRespawnPaused;
var repnotify class<Inventory> InventoryType;
var float RespawnEffectTime;
var float MaxDesireability;
var export editinline PrimitiveComponent PickupMesh;
var PickupFactory ReplacementFactory;
var PickupFactory OriginalFactory;

replication
{
    // Pos:0x000
    if(bNetDirty && Role == ROLE_Authority)
        bPickupHidden

    // Pos:0x020
    if(bNetInitial && Role == ROLE_Authority)
        InventoryType
}

simulated event ReplicatedEvent(name VarName)
{
    // End:0x3E
    if(VarName == 'bPickupHidden')
    {
        // End:0x31
        if(bPickupHidden)
        {
            SetPickupHidden();
        }
        // End:0x3B
        else
        {
            SetPickupVisible();
        }
    }
    // End:0x5F
    else
    {
        // End:0x5F
        if(VarName == 'InventoryType')
        {
            InitializePickup();
        }
    }
    //return;    
}

simulated event PreBeginPlay()
{
    InitializePickup();
    super(Actor).PreBeginPlay();
    //return;    
}

simulated function InitializePickup()
{
    // End:0x2F
    if(InventoryType == none)
    {
        WarnInternal("No inventory type for" @ string(self));
        return;
    }
    bPredictRespawns = InventoryType.default.bPredictRespawns;
    MaxDesireability = InventoryType.default.MaxDesireability;
    SetPickupMesh();
    bIsSuperItem = InventoryType.default.bDelayedSpawn;
    //return;    
}

simulated event SetInitialState()
{
    bScriptInitialized = true;
    // End:0x58
    if(InventoryType == none)
    {
        WarnInternal("Disabling as no inventory type for " $ string(self));
        GotoState('Disabled');
    }
    // End:0x80
    else
    {
        // End:0x76
        if(bIsSuperItem)
        {
            GotoState('WaitingForMatch');
        }
        // End:0x80
        else
        {
            super(Actor).SetInitialState();
        }
    }
    //return;    
}

simulated function ShutDown()
{
    GotoState('Disabled');
    //return;    
}

simulated function SetPickupMesh()
{
    // End:0xE7
    if(InventoryType.default.PickupFactoryMesh != none)
    {
        // End:0x51
        if(PickupMesh != none)
        {
            DetachComponent(PickupMesh);
            PickupMesh = none;
        }
        PickupMesh = new (self) InventoryType.default.PickupFactoryMesh.Class (InventoryType.default.PickupFactoryMesh);
        AttachComponent(PickupMesh);
        // End:0xDD
        if(bPickupHidden)
        {
            SetPickupHidden();
        }
        // End:0xE7
        else
        {
            SetPickupVisible();
        }
    }
    //return;    
}

function Reset()
{
    // End:0x1E
    if(bIsSuperItem)
    {
        GotoState('Sleeping');
    }
    // End:0x2C
    else
    {
        GotoState('Pickup');
    }
    super(Actor).Reset();
    //return;    
}

function bool CheckForErrors()
{
    local Actor HitActor;
    local Vector HitLocation, HitNormal;

    HitActor = Trace(HitLocation, HitNormal, Location - vect(0.0, 0.0, 10.0), Location, false);
    // End:0x68
    if(HitActor == none)
    {
        LogInternal(string(self) $ " FLOATING");
        return true;
    }
    return super(Actor).CheckForErrors();
    //return ReturnValue;    
}

function SetRespawn()
{
    // End:0x6D
    if((InventoryType.default.RespawnTime != float(0)) && WorldInfo.Game.ShouldRespawn(self))
    {
        StartSleeping();
    }
    // End:0x7B
    else
    {
        GotoState('Disabled');
    }
    //return;    
}

function StartSleeping()
{
    GotoState('Sleeping');
    //return;    
}

event float DetourWeight(Pawn Other, float PathWeight)
{
    return ((ReplacementFactory != none) ? ReplacementFactory.DetourWeight(Other, PathWeight) : 0.0);
    //return ReturnValue;    
}

function SpawnCopyFor(Pawn Recipient)
{
    local Inventory Inv;

    Inv = Spawn(InventoryType);
    // End:0x82
    if(Inv != none)
    {
        Inv.GiveTo(Recipient);
        Inv.AnnouncePickup(Recipient);
    }
    //return;    
}

function bool ReadyToPickup(float MaxWait)
{
    return false;
    //return ReturnValue;    
}

function GiveTo(Pawn P)
{
    SpawnCopyFor(P);
    PickedUpBy(P);
    //return;    
}

function PickedUpBy(Pawn P)
{
    SetRespawn();
    TriggerEventClass(class'SeqEvent_PickupStatusChange', P, 1);
    // End:0xE1
    if((P.Controller != none) && P.Controller.MoveTarget == self)
    {
        P.SetAnchor(self);
        P.Controller.MoveTimer = -1.0;
    }
    //return;    
}

function RecheckValidTouch()
{
    //return;    
}

function float GetRespawnTime()
{
    return InventoryType.default.RespawnTime;
    //return ReturnValue;    
}

function RespawnEffect()
{
    //return;    
}

simulated function SetPickupHidden()
{
    bForceNetUpdate = true;
    bPickupHidden = true;
    // End:0x47
    if(PickupMesh != none)
    {
        PickupMesh.SetHidden(true);
    }
    //return;    
}

simulated function SetPickupVisible()
{
    bForceNetUpdate = true;
    bPickupHidden = false;
    // End:0x47
    if(PickupMesh != none)
    {
        PickupMesh.SetHidden(false);
    }
    //return;    
}

event Destroyed()
{
    // End:0x37
    if(OriginalFactory != none)
    {
        OriginalFactory.ReplacementFactory = ReplacementFactory;
    }
    // End:0x6E
    if(ReplacementFactory != none)
    {
        ReplacementFactory.OriginalFactory = OriginalFactory;
    }
    //return;    
}

function bool DelayRespawn()
{
    return false;
    //return ReturnValue;    
}

auto state Pickup
{
    event float DetourWeight(Pawn Other, float PathWeight)
    {
        return InventoryType.static.DetourWeight(Other, PathWeight);
        //return ReturnValue;        
    }

    function bool ReadyToPickup(float MaxWait)
    {
        return true;
        //return ReturnValue;        
    }

    function bool ValidTouch(Pawn Other)
    {
        // End:0x3A
        if((Other == none) || !Other.bCanPickupInventory)
        {
            return false;
        }
        // End:0xBC
        else
        {
            // End:0x76
            if(Other.Controller == none)
            {
                SetTimer(0.20, false, 'RecheckValidTouch');
                return false;
            }
            // End:0xBC
            else
            {
                // End:0xBC
                if(!FastTrace(Other.Location, Location))
                {
                    SetTimer(0.50, false, 'RecheckValidTouch');
                    return false;
                }
            }
        }
        // End:0x108
        if(WorldInfo.Game.PickupQuery(Other, InventoryType, self))
        {
            return true;
        }
        return false;
        //return ReturnValue;        
    }

    function RecheckValidTouch()
    {
        CheckTouching();
        //return;        
    }

    event Touch(Actor Other, PrimitiveComponent OtherComp, Vector HitLocation, Vector HitNormal)
    {
        local Pawn P;

        P = Pawn(Other);
        // End:0x56
        if((P != none) && ValidTouch(P))
        {
            GiveTo(P);
        }
        //return;        
    }

    function CheckTouching()
    {
        local Pawn P;

        // End:0x61
        foreach TouchingActors(class'Pawn', P)
        {
            Touch(P, none, Location, Normal(Location - P.Location));            
        }        
        //return;        
    }

    event BeginState(name PreviousStateName)
    {
        TriggerEventClass(class'SeqEvent_PickupStatusChange', none, 0);
        //return;        
    }

Begin:
    CheckTouching();
    stop;        
}

state WaitingForMatch
{
    ignores Touch;

    function MatchStarting()
    {
        GotoState('Sleeping');
        //return;        
    }

    event BeginState(name PreviousStateName)
    {
        SetPickupHidden();
        //return;        
    }
    stop;    
}

state Sleeping
{
    ignores Touch, StartSleeping;

    function bool ReadyToPickup(float MaxWait)
    {
        return ((bPredictRespawns && !bRespawnPaused) && LatentFloat <= MaxWait) && LatentFloat > 0.0;
        //return ReturnValue;        
    }

    event BeginState(name PreviousStateName)
    {
        SetPickupHidden();
        //return;        
    }

    event EndState(name NextStateName)
    {
        SetPickupVisible();
        //return;        
    }

Begin:
    bRespawnPaused = true;
    J0x0C:
    // End:0x24 [Loop If]
    if(DelayRespawn())
    {
        Sleep(1.0);
        // [Loop Continue]
        goto J0x0C;
    }
    bRespawnPaused = false;
    Sleep((GetRespawnTime()) - RespawnEffectTime);
Respawn:

    RespawnEffect();
    Sleep(RespawnEffectTime);
    GotoState('Pickup');
    stop;                
}

state Disabled
{
    ignores Reset, StartSleeping;

    function bool ReadyToPickup(float MaxWait)
    {
        return false;
        //return ReturnValue;        
    }

    simulated event SetInitialState()
    {
        bScriptInitialized = true;
        //return;        
    }

    simulated event BeginState(name PreviousStateName)
    {
        SetPickupHidden();
        SetCollision(false, false);
        //return;        
    }

    simulated event EndState(name NextStateName)
    {
        SetPickupVisible();
        //return;        
    }
    stop;    
}

defaultproperties
{
    bOnlyReplicateHidden=true
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionHeight=80.0
        CollisionRadius=40.0
        ReplacementPrimitive=none
        CollideActors=true
    object end
    // Reference: CylinderComponent'Default__PickupFactory.CollisionCylinder'
    CylinderComponent=CollisionCylinder
    begin object name=Sprite class=SpriteComponent
        ReplacementPrimitive=none
    object end
    // Reference: SpriteComponent'Default__PickupFactory.Sprite'
    GoodSprite=Sprite
    begin object name=Sprite2 class=SpriteComponent
        ReplacementPrimitive=none
    object end
    // Reference: SpriteComponent'Default__PickupFactory.Sprite2'
    BadSprite=Sprite2
    begin object name=Sprite class=SpriteComponent
        ReplacementPrimitive=none
    object end
    // Reference: SpriteComponent'Default__PickupFactory.Sprite'
    Components(0)=Sprite
    begin object name=Sprite2 class=SpriteComponent
        ReplacementPrimitive=none
    object end
    // Reference: SpriteComponent'Default__PickupFactory.Sprite2'
    Components(1)=Sprite2
    begin object name=Arrow class=ArrowComponent
        ReplacementPrimitive=none
    object end
    // Reference: ArrowComponent'Default__PickupFactory.Arrow'
    Components(2)=Arrow
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionHeight=80.0
        CollisionRadius=40.0
        ReplacementPrimitive=none
        CollideActors=true
    object end
    // Reference: CylinderComponent'Default__PickupFactory.CollisionCylinder'
    Components(3)=CollisionCylinder
    begin object name=PathRenderer class=PathRenderingComponent
        ReplacementPrimitive=none
    object end
    // Reference: PathRenderingComponent'Default__PickupFactory.PathRenderer'
    Components(4)=PathRenderer
    RemoteRole=ENetRole.ROLE_SimulatedProxy
    TickGroup=ETickingGroup.TG_DuringAsyncWork
    bStatic=false
    bIgnoreEncroachers=true
    bAlwaysRelevant=true
    bCollideWhenPlacing=false
    bCollideActors=true
    NetUpdateFrequency=1.0
    begin object name=CollisionCylinder class=CylinderComponent
        CollisionHeight=80.0
        CollisionRadius=40.0
        ReplacementPrimitive=none
        CollideActors=true
    object end
    // Reference: CylinderComponent'Default__PickupFactory.CollisionCylinder'
    CollisionComponent=CollisionCylinder
    SupportedEvents(0)=class'SeqEvent_Touch'
    SupportedEvents(1)=class'SeqEvent_Destroyed'
    SupportedEvents(2)=class'SeqEvent_TakeDamage'
    SupportedEvents(3)=class'SeqEvent_HitWall'
    SupportedEvents(4)=class'SeqEvent_AnimNotify'
    SupportedEvents(5)=class'SeqEvent_MobileTouch'
    SupportedEvents(6)=class'SeqEvent_PickupStatusChange'
}