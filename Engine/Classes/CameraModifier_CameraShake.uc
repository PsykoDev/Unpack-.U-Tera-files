/*******************************************************************************
 * CameraModifier_CameraShake generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2015 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class CameraModifier_CameraShake extends CameraModifier
    native(Camera);

struct native CameraShakeInstance
{
    var CameraShake SourceShake;
    var name SourceShakeName;
    var float OscillatorTimeRemaining;
    var bool bBlendingIn;
    var float CurrentBlendInTime;
    var bool bBlendingOut;
    var float CurrentBlendOutTime;
    var Vector LocSinOffset;
    var Vector RotSinOffset;
    var float FOVSinOffset;
    var float Scale;
    var CameraAnimInst AnimInst;
    var Camera.ECameraAnimPlaySpace PlaySpace;
    var Matrix UserPlaySpaceMatrix;

    structdefaultproperties
    {
        SourceShake=none
        SourceShakeName=None
        OscillatorTimeRemaining=0.0
        bBlendingIn=false
        CurrentBlendInTime=0.0
        bBlendingOut=false
        CurrentBlendOutTime=0.0
        LocSinOffset=(X=0.0,Y=0.0,Z=0.0)
        RotSinOffset=(X=0.0,Y=0.0,Z=0.0)
        FOVSinOffset=0.0
        Scale=0.0
        AnimInst=none
        PlaySpace=ECameraAnimPlaySpace.CAPS_CameraLocal
        UserPlaySpaceMatrix=(XPlane=(X=0.0,Y=0.0,Z=0.0,W=0.0),YPlane=(X=0.0,Y=0.0,Z=0.0,W=0.0),ZPlane=(X=0.0,Y=0.0,Z=0.0,W=0.0),WPlane=(X=0.0,Y=0.0,Z=0.0,W=0.0))
    }
};

var array<CameraShakeInstance> ActiveShakes;
/** Scalar applied to all camera shakes in splitscreen. Normally used to dampen, since shakes feel more intense in a smaller viewport. */
var() protected const float SplitScreenShakeScale;

protected static function float InitializeOffset(const out FOscillator Param)
{
    switch(Param.InitialOffset)
    {
        // End:0x3E
        case 0:
            return (FRand() * float(2)) * 3.1415930;
            // End:0x4F
            break;
        // End:0x4C
        case 1:
            return 0.0;
            // End:0x4F
            break;
        // End:0xFFFF
        default:
            return 0.0;
    }
    //return ReturnValue;    
}

protected function ReinitShake(int ActiveShakeIdx, float Scale)
{
    local CameraShake SourceShake;
    local float Duration;
    local bool bRandomStart, bLoop;

    // End:0x36
    if(class'Engine'.static.IsSplitScreen())
    {
        Scale *= SplitScreenShakeScale;
    }
    ActiveShakes[ActiveShakeIdx].Scale = Scale;
    SourceShake = ActiveShakes[ActiveShakeIdx].SourceShake;
    // End:0x279
    if(SourceShake.OscillationDuration != 0.0)
    {
        ActiveShakes[ActiveShakeIdx].OscillatorTimeRemaining = SourceShake.OscillationDuration;
        // End:0x279
        if(ActiveShakes[ActiveShakeIdx].bBlendingOut)
        {
            ActiveShakes[ActiveShakeIdx].bBlendingOut = false;
            ActiveShakes[ActiveShakeIdx].CurrentBlendOutTime = 0.0;
            ActiveShakes[ActiveShakeIdx].bBlendingIn = true;
            ActiveShakes[ActiveShakeIdx].CurrentBlendInTime = ActiveShakes[ActiveShakeIdx].SourceShake.OscillationBlendInTime * (1.0 - (ActiveShakes[ActiveShakeIdx].CurrentBlendOutTime / ActiveShakes[ActiveShakeIdx].SourceShake.OscillationBlendOutTime));
        }
    }
    // End:0x3E4
    if(SourceShake.Anim != none)
    {
        // End:0x2FF
        if(SourceShake.bRandomAnimSegment)
        {
            bLoop = true;
            bRandomStart = true;
            Duration = SourceShake.RandomAnimSegmentDuration;
        }
        ActiveShakes[ActiveShakeIdx].AnimInst = CameraOwner.PlayCameraAnim(SourceShake.Anim, SourceShake.AnimPlayRate, Scale, SourceShake.AnimBlendInTime, SourceShake.AnimBlendOutTime, bLoop, bRandomStart, Duration, true);
    }
    //return;    
}

protected function CameraShakeInstance InitializeShake(CameraShake NewShake, float Scale, Camera.ECameraAnimPlaySpace PlaySpace, optional Rotator UserPlaySpaceRot)
{
    local CameraShakeInstance Inst;
    local float Duration;
    local bool bRandomStart, bLoop;

    Inst.SourceShakeName = NewShake.Name;
    Inst.SourceShake = new (self) NewShake.Class;
    Inst.SourceShake.OscillationDuration = NewShake.OscillationDuration;
    Inst.SourceShake.OscillationBlendInTime = NewShake.OscillationBlendInTime;
    Inst.SourceShake.OscillationBlendOutTime = NewShake.OscillationBlendOutTime;
    Inst.SourceShake.RotOscillation = NewShake.RotOscillation;
    Inst.SourceShake.LocOscillation = NewShake.LocOscillation;
    Inst.SourceShake.FOVOscillation = NewShake.FOVOscillation;
    Inst.SourceShake.Anim = NewShake.Anim;
    Inst.SourceShake.AnimPlayRate = NewShake.AnimPlayRate;
    Inst.SourceShake.AnimBlendInTime = NewShake.AnimBlendInTime;
    Inst.SourceShake.AnimBlendOutTime = NewShake.AnimBlendOutTime;
    Inst.SourceShake.bRandomAnimSegment = NewShake.bRandomAnimSegment;
    Inst.SourceShake.RandomAnimSegmentDuration = NewShake.RandomAnimSegmentDuration;
    Inst.Scale = Scale;
    // End:0x49A
    if(class'Engine'.static.IsSplitScreen())
    {
        Scale *= SplitScreenShakeScale;
    }
    // End:0x82D
    if(NewShake.OscillationDuration != 0.0)
    {
        Inst.RotSinOffset.X = InitializeOffset(NewShake.RotOscillation.Pitch);
        Inst.RotSinOffset.Y = InitializeOffset(NewShake.RotOscillation.Yaw);
        Inst.RotSinOffset.Z = InitializeOffset(NewShake.RotOscillation.Roll);
        Inst.LocSinOffset.X = InitializeOffset(NewShake.LocOscillation.X);
        Inst.LocSinOffset.Y = InitializeOffset(NewShake.LocOscillation.Y);
        Inst.LocSinOffset.Z = InitializeOffset(NewShake.LocOscillation.Z);
        Inst.FOVSinOffset = InitializeOffset(NewShake.FOVOscillation);
        Inst.OscillatorTimeRemaining = NewShake.OscillationDuration;
        // End:0x82D
        if(NewShake.OscillationBlendInTime > 0.0)
        {
            Inst.bBlendingIn = true;
            Inst.CurrentBlendInTime = 0.0;
        }
    }
    // End:0xA3B
    if(NewShake.Anim != none)
    {
        // End:0x8B3
        if(NewShake.bRandomAnimSegment)
        {
            bLoop = true;
            bRandomStart = true;
            Duration = NewShake.RandomAnimSegmentDuration;
        }
        // End:0xA3B
        if(Scale > 0.0)
        {
            Inst.AnimInst = CameraOwner.PlayCameraAnim(NewShake.Anim, NewShake.AnimPlayRate, Scale, NewShake.AnimBlendInTime, NewShake.AnimBlendOutTime, bLoop, bRandomStart, Duration, NewShake.bSingleInstance);
            // End:0xA3B
            if((PlaySpace != 0) && Inst.AnimInst != none)
            {
                Inst.AnimInst.SetPlaySpace(PlaySpace, UserPlaySpaceRot);
            }
        }
    }
    Inst.PlaySpace = PlaySpace;
    // End:0xAB8
    if(Inst.PlaySpace == 2)
    {
        Inst.UserPlaySpaceMatrix = MakeRotationMatrix(UserPlaySpaceRot);
    }
    return Inst;
    //return ReturnValue;    
}

function AddCameraShake(CameraShake NewShake, float Scale, optional Camera.ECameraAnimPlaySpace PlaySpace, optional Rotator UserPlaySpaceRot)
{
    local int ShakeIdx, NumShakes;

    PlaySpace = 0;    
    // End:0xFD
    if(NewShake != none)
    {
        // End:0xA7
        if(NewShake.bSingleInstance)
        {
            ShakeIdx = ActiveShakes.Find('SourceShakeName', NewShake.Name);
            // End:0xA7
            if(ShakeIdx != -1)
            {
                ReinitShake(ShakeIdx, Scale);
                return;
            }
        }
        NumShakes = ActiveShakes.Length;
        ActiveShakes[NumShakes] = InitializeShake(NewShake, Scale, PlaySpace, UserPlaySpaceRot);
    }
    //return;    
}

function RemoveCameraShake(CameraShake Shake)
{
    local int Idx;
    local CameraAnimInst AnimInst;

    Idx = ActiveShakes.Find('SourceShakeName', Shake.Name);
    // End:0xF4
    if(Idx != -1)
    {
        AnimInst = ActiveShakes[Idx].AnimInst;
        // End:0xDF
        if((AnimInst != none) && !AnimInst.bFinished)
        {
            CameraOwner.StopCameraAnim(AnimInst, true);
        }
        ActiveShakes.Remove(Idx, 1);
    }
    //return;    
}

function RemoveAllCameraShakes()
{
    local int Idx;
    local CameraAnimInst AnimInst;

    Idx = 0;
    J0x0B:
    // End:0xBF [Loop If]
    if(Idx < ActiveShakes.Length)
    {
        AnimInst = ActiveShakes[Idx].AnimInst;
        // End:0xB1
        if((AnimInst != none) && !AnimInst.bFinished)
        {
            CameraOwner.StopCameraAnim(AnimInst, true);
        }
        ++ Idx;
        // [Loop Continue]
        goto J0x0B;
    }
    ActiveShakes.Length = 0;
    //return;    
}

// Export UCameraModifier_CameraShake::execUpdateCameraShake(FFrame&, void* const)
native function UpdateCameraShake(float DeltaTime, out CameraShakeInstance Shake, out TPOV OutPOV);

// Export UCameraModifier_CameraShake::execModifyCamera(FFrame&, void* const)
native function bool ModifyCamera(Camera Camera, float DeltaTime, out TPOV OutPOV);

defaultproperties
{
    SplitScreenShakeScale=0.50
}