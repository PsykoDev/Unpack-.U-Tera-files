/*******************************************************************************
 * Actor generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2015 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class Actor extends Object
    abstract
    native
    nativereplication
    hidecategories(Navigation);

const TRACEFLAG_Bullet = 1;
const TRACEFLAG_PhysicsVolumes = 2;
const TRACEFLAG_SkipMovers = 4;
const TRACEFLAG_Blocking = 8;
const TRACEFLAG_ForceController = 16;
const REP_RBLOCATION_ERROR_TOLERANCE_SQ = 16.0f;
const MINFLOORZ = 0.7;
const ACTORMAXSTEPHEIGHT = 35.0;
const RBSTATE_LINVELSCALE = 10.0;
const RBSTATE_ANGVELSCALE = 1000.0;
const RB_None = 0x00;
const RB_NeedsUpdate = 0x01;
const RB_Sleeping = 0x02;

enum EPhysics
{
    PHYS_None,
    PHYS_Walking,
    PHYS_Falling,
    PHYS_Swimming,
    PHYS_Flying,
    PHYS_Rotating,
    PHYS_Projectile,
    PHYS_Interpolating,
    PHYS_Spider,
    PHYS_Ladder,
    PHYS_RigidBody,
    PHYS_SoftBody,
    PHYS_NavMeshWalking,
    PHYS_Unused,
    PHYS_Custom,
    PHYS_MAX
};

enum EMoveDir
{
    MD_Stationary,
    MD_Forward,
    MD_Backward,
    MD_Left,
    MD_Right,
    MD_Up,
    MD_Down,
    MD_MAX
};

enum EActorMetricsType
{
    METRICS_VERTS,
    METRICS_TRIS,
    METRICS_SECTIONS,
    METRICS_MAX
};

enum ENetRole
{
    ROLE_None,
    ROLE_SimulatedProxy,
    ROLE_AutonomousProxy,
    ROLE_Authority,
    ROLE_MAX
};

enum ECollisionType
{
    COLLIDE_CustomDefault,
    COLLIDE_NoCollision,
    COLLIDE_BlockAll,
    COLLIDE_BlockWeapons,
    COLLIDE_TouchAll,
    COLLIDE_TouchWeapons,
    COLLIDE_BlockAllButWeapons,
    COLLIDE_TouchAllButWeapons,
    COLLIDE_BlockWeaponsKickable,
    COLLIDE_MAX
};

enum ETravelType
{
    TRAVEL_Absolute,
    TRAVEL_Partial,
    TRAVEL_Relative,
    TRAVEL_MAX
};

enum EDoubleClickDir
{
    DCLICK_None,
    DCLICK_Left,
    DCLICK_Right,
    DCLICK_Forward,
    DCLICK_Back,
    DCLICK_Active,
    DCLICK_Done,
    DCLICK_MAX
};

struct native TimerData
{
    var bool bLoop;
    var bool bPaused;
    var name FuncName;
    var float Rate;
    var float Count;
    var float TimerTimeDilation;
    var Object TimerObj;

    structdefaultproperties
    {
        bLoop=false
        bPaused=false
        FuncName=None
        Rate=0.0
        Count=0.0
        TimerTimeDilation=1.0
        TimerObj=none
    }
};

struct native transient TraceHitInfo
{
    var init Material Material;
    var init PhysicalMaterial PhysMaterial;
    var init int Item;
    var init int LevelIndex;
    var init name BoneName;
    var init export editinline PrimitiveComponent HitComponent;

    structdefaultproperties
    {
        Material=none
        PhysMaterial=none
        Item=0
        LevelIndex=0
        BoneName=None
        HitComponent=none
    }
};

struct native transient ImpactInfo
{
    var init Actor HitActor;
    var init Vector HitLocation;
    var init Vector HitNormal;
    var init Vector RayDir;
    var init Vector StartTrace;
    var init TraceHitInfo HitInfo;

    structdefaultproperties
    {
        HitActor=none
        HitLocation=(X=0.0,Y=0.0,Z=0.0)
        HitNormal=(X=0.0,Y=0.0,Z=0.0)
        RayDir=(X=0.0,Y=0.0,Z=0.0)
        StartTrace=(X=0.0,Y=0.0,Z=0.0)
        HitInfo=(Material=none,PhysMaterial=none,Item=0,LevelIndex=0,BoneName=None,HitComponent=none)
    }
};

struct native transient AnimSlotInfo
{
    var init name SlotName;
    var init array<float> ChannelWeights;

    structdefaultproperties
    {
        SlotName=None
        ChannelWeights=none
    }
};

struct native transient AnimSlotDesc
{
    var init name SlotName;
    var init int NumChannels;

    structdefaultproperties
    {
        SlotName=None
        NumChannels=0
    }
};

struct RigidBodyState
{
    var Vector Position;
    var Quat Quaternion;
    var Vector LinVel;
    var Vector AngVel;
    var byte bNewData;

    structdefaultproperties
    {
        Position=(X=0.0,Y=0.0,Z=0.0)
        Quaternion=(X=0.0,Y=0.0,Z=0.0,W=0.0)
        LinVel=(X=0.0,Y=0.0,Z=0.0)
        AngVel=(X=0.0,Y=0.0,Z=0.0)
        bNewData=0
    }
};

struct RigidBodyContactInfo
{
    var Vector ContactPosition;
    var Vector ContactNormal;
    var float ContactPenetration;
    var Vector ContactVelocity[2];
    var PhysicalMaterial PhysMaterial[2];

    structdefaultproperties
    {
        ContactPosition=(X=0.0,Y=0.0,Z=0.0)
        ContactNormal=(X=0.0,Y=0.0,Z=0.0)
        ContactPenetration=0.0
        ContactVelocity[0]=(X=0.0,Y=0.0,Z=0.0)
        ContactVelocity[1]=(X=0.0,Y=0.0,Z=0.0)
        PhysMaterial[0]=none
        PhysMaterial[1]=none
    }
};

struct CollisionImpactData
{
    var array<RigidBodyContactInfo> ContactInfos;
    var Vector TotalNormalForceVector;
    var Vector TotalFrictionForceVector;

    structdefaultproperties
    {
        ContactInfos=none
        TotalNormalForceVector=(X=0.0,Y=0.0,Z=0.0)
        TotalFrictionForceVector=(X=0.0,Y=0.0,Z=0.0)
    }
};

struct native PhysEffectInfo
{
    /** Struct used to pass back information for physical impact effect */
    var() float Threshold;
    /** Struct used to pass back information for physical impact effect */
    var() float ReFireDelay;
    /** Struct used to pass back information for physical impact effect */
    var() ParticleSystem Effect;
    /** Struct used to pass back information for physical impact effect */
    var() SoundCue Sound;

    structdefaultproperties
    {
        Threshold=0.0
        ReFireDelay=0.0
        Effect=none
        Sound=none
    }
};

struct native atomicwhencooked immutablewhencooked ActorReference
{
    /** Struct used for cross level actor references */
    var() Actor Actor;
    /** Struct used for cross level actor references */
    var() const editconst Guid Guid;

    structdefaultproperties
    {
        Actor=none
        Guid=(A=0,B=0,C=0,D=0)
    }
};

struct native atomicwhencooked immutablewhencooked NavReference
{
    var() NavigationPoint Nav;
    var() const editconst Guid Guid;

    structdefaultproperties
    {
        Nav=none
        Guid=(A=0,B=0,C=0,D=0)
    }
};

struct native BasedPosition
{
    /** Struct for handling positions relative to a base actor, which is potentially moving */
    var() Actor Base;
    /** Struct for handling positions relative to a base actor, which is potentially moving */
    var() Vector Position;
    var Vector CachedBaseLocation;
    var Rotator CachedBaseRotation;
    var Vector CachedTransPosition;

    structdefaultproperties
    {
        Base=none
        Position=(X=0.0,Y=0.0,Z=0.0)
        CachedBaseLocation=(X=0.0,Y=0.0,Z=0.0)
        CachedBaseRotation=(Pitch=0,Yaw=0,Roll=0)
        CachedTransPosition=(X=0.0,Y=0.0,Z=0.0)
    }
};

var private const export editinline array<export editinline ActorComponent> Components;
var private const export editinline transient array<export editinline ActorComponent> AllComponents;
/** Actor's location; use Move or SetLocation to change. */
var(Movement) const Vector Location;
/** The actor's rotation; use SetRotation to change. */
var(Movement) const Rotator Rotation;
/** Scaling factor, 1.0=normal size. */
var(Display) repnotify interp const float DrawScale<UIMin=0.1|UIMax=4.0>;
/** Scaling vector, (1.0,1.0,1.0)=normal size. */
var(Display) interp const Vector DrawScale3D;
/** Offset from box center for drawing. */
var(Display) const Vector PrePivot;
/** Color to tint the icon for this actor */
var(Display) editoronly Color EditorIconColor;
var private native const RenderCommandFence DetachFence;
var float CustomTimeDilation;
/** Priority Parameters Actor's current physics mode. */
var(Movement) const Actor.EPhysics Physics;
var Actor.ENetRole RemoteRole;
var Actor.ENetRole Role;
/** enum for LDs to select collision options - sets Actor flags and that of our CollisionComponent via PostEditChange() */
var(Collision) const transient Actor.ECollisionType CollisionType;
var transient Actor.ECollisionType ReplicatedCollisionType;
var const Core.Object.ETickingGroup TickGroup;
/** #if WITH_S1airsulg              true?? editor?? Actor? ???? ???. */
var(Advanced) editoronly bool bFreezeActor;
var transient bool bS1GameObject;
var const bool bStatic;
var(Display) const bool bHidden;
var const transient bool bSkeletonHidden;
var const bool bNoDelete;
var const bool bDeleteMe;
var const transient bool bTicked;
var const bool bOnlyOwnerSee;
var const bool bTickIsDisabled;
var bool bWorldGeometry;
var bool bIgnoreRigidBodyPawns;
var bool bOrientOnSlope;
var const bool bIgnoreEncroachers;
var bool bPushedByEncroachers;
var bool bDestroyedByInterpActor;
var const bool bRouteBeginPlayEvenIfStatic;
var const bool bIsMoving;
var bool bAlwaysEncroachCheck;
var bool bHasAlternateTargetLocation;
/** If TRUE, PHYS_Walking will attempt to step up onto this object when it hits it */
var(Collision) bool bCanStepUpOn;
var const bool bNetTemporary;
var const bool bOnlyRelevantToOwner;
var transient bool bNetDirty;
var bool bAlwaysRelevant;
var bool bReplicateInstigator;
var bool bReplicateMovement;
var bool bSkipActorPropertyReplication;
var bool bUpdateSimulatedPosition;
var bool bTearOff;
var bool bOnlyDirtyReplication;
var(Physics) bool bAllowFluidSurfaceInteraction;
var transient bool bDemoRecording;
var bool bDemoOwner;
var bool bForceDemoRelevant;
var const bool bNetInitialRotation;
var bool bReplicateRigidBodyLocation;
var bool bKillDuringLevelTransition;
var const bool bExchangedRoles;
/** If true, texture streaming code iterates over all StaticMeshComponents found on this actor when building texture streaming information. */
var(Advanced) bool bConsiderAllStaticMeshComponentsForStreaming;
/** debug */
var(Debug) bool bDebug;
var bool bPostRenderIfNotVisible;
var transient bool bForceNetUpdate;
var const transient bool bPendingNetUpdate;
/**  
 *Uses 'hard' attachment code. bBlockActor must also be false.
 *       This actor cannot then move relative to base (setlocation etc.).
 *       Dont set while currently based on something!
 */
var(Attachment) const bool bHardAttach;
/** If TRUE, this actor ignores the effects of changes in its  base's rotation on its location and rotation. */
var(Attachment) bool bIgnoreBaseRotation;
/** If TRUE, BaseSkelComponent is used as the shadow parent for this actor. */
var(Attachment) bool bShadowParented;
/**  
 *If TRUE, Skip moveactor collision check for this actor moving as a result of its base, to which it is hard attached moving
 * - only if this actor doesn't block actors.
 */
var(Attachment) bool bSkipAttachedMoves;
var bool bCanBeAdheredTo;
var bool bCanBeFrictionedTo;
var bool bHurtEntry;
var bool bGameRelevant;
var const bool bMovable;
var bool bDestroyInPainVolume;
var bool bCanBeDamaged;
var bool bShouldBaseAtStartup;
var bool bPendingDelete;
var bool bCanTeleport;
var const bool bAlwaysTick;
var(Navigation) bool bBlocksNavigation;
/**  
 *mirrored copy of CollisionComponent's BlockRigidBody for the Actor property window for LDs (so it's next to CollisionType)
 * purely for editing convenience and not used at all by the physics code
 */
var(Collision) const transient bool BlockRigidBody;
var bool bCollideWhenPlacing;
var const bool bCollideActors;
var bool bCollideWorld;
/** Ignore Simple Collision on Static Meshes, and collide per Poly. */
var(Collision) bool bCollideComplex;
var bool bBlockActors;
var bool bProjTarget;
var bool bBlocksTeleport;
var bool bMoveIgnoresDestruction;
var bool bProjectileMoveSingleBlocking;
/**  
 *For encroachers, don't do the overlap check when they move. You will not get touch events for this actor moving, but it is much faster.
 *       So if you want touch events from volumes or triggers you need to set this to be FALSE.
 *       This is an optimisation for large numbers of PHYS_RigidBody actors for example.
 */
var(Collision) bool bNoEncroachCheck;
var bool bCollideAsEncroacher;
/** If true, do a zero-extent trace each frame from old to new Location when in PHYS_RigidBody. If it hits the world (ie might be tunneling), call FellOutOfWorld. */
var(Collision) bool bPhysRigidBodyOutOfWorldCheck;
var const transient bool bComponentOutsideWorld;
var bool bForceOctreeSNFilter;
var bool bForceOctreeMNFilter;
var const transient bool bRigidBodyWasAwake;
var bool bCallRigidBodyWakeEvents;
var bool bBounce;
var const bool bJustTeleported;
/** Enable this actor to receive the OnMobileTouch event when a player touches this actor when using a touch screen device */
var(Mobile) bool bEnableMobileTouch;
var const bool bNetInitial;
var const bool bNetOwner;
var const bool bHiddenEd;
var const bool bEditable;
var const deprecated bool bHiddenEdGroup;
var const bool bHiddenEdLayer;
var const bool bHiddenEdCustom;
var editoronly transient bool bHiddenEdTemporary;
var editoronly transient bool bHiddenEdLevel;
var editoronly transient bool bHiddenEdScene;
/** Snap to grid in editor. */
var(Advanced) bool bEdShouldSnap;
var const transient bool bTempEditor;
/** this actor should collide (if bWorldGeometry && bBlockActors is true) during path building (ignored if bStatic is true, as actor will always collide during path building) */
var(Collision) bool bPathColliding;
var transient bool bPathTemp;
var bool bScriptInitialized;
/** always allow Kismet to modify this Actor, even if it's static and not networked (e.g. for server side only stuff) */
var(Advanced) bool bLockLocation;
var const bool bForceAllowKismetModification;
var(Debug) bool bDebugEffectIsRelevant;
var const Actor Owner;
/** Actor we're standing on. */
var(Attachment) const Actor Base;
var const array<TimerData> Timers;
var const transient int SkelMeshCompTickTag;
var const transient int NetTag;
var const float NetUpdateTime;
var float NetUpdateFrequency;
var float NetPriority;
var const transient float LastNetUpdateTime;
var float TimeSinceLastTick;
var Pawn Instigator;
var const transient WorldInfo WorldInfo;
var float LifeSpan;
var const float CreationTime;
var transient float LastRenderTime;
/** Actor's tag name. */
var(Object) name Tag;
var name InitialState;
/** Actor's layer name. */
var(Object) name Layer;
var deprecated name Group;
var transient QWord HiddenEditorViews;
var const transient array<Actor> Touching;
var const transient array<Actor> Children;
var const float LatentFloat;
var const AnimNodeSequence LatentSeqNode;
var const transient Pointer CriticalSection;
var const transient PhysicsVolume PhysicsVolume;
var Vector Velocity;
var Vector Acceleration;
var const transient Vector AngularVelocity;
/** Attachment related variables */
var(Attachment) export editinline SkeletalMeshComponent BaseSkelComponent;
var(Attachment) name BaseBoneName;
var const array<Actor> Attached;
var const Vector RelativeLocation;
var const Rotator RelativeRotation;
/** ----------------------------------------------------------------------------- Collision. Collision primitive. */
var(Collision) editconst export editinline PrimitiveComponent CollisionComponent;
var native int OverlapTag;
/**  
 *PLEASE NOTE DesiredRotation is removed
 *  This DesiredRotation is moved to Pawn to remove redundant variables usage. (i.e. between Pawn and Controller)
 *  Pawn now handles all DesiredRotation and it is only one place.
 *  All Actor's DesiredRotation won't work anymore - Use RotationRate to control Actor's rotation
 */
var(Movement) Rotator RotationRate;
var Actor PendingTouch;
var class<LocalMessage> MessageClass;
var const array< class<SequenceEvent> > SupportedEvents;
var const array<SequenceEvent> GeneratedEvents;
var array<SeqAct_Latent> LatentActions;

replication
{
    // Pos:0x000
    if(((!bSkipActorPropertyReplication || bNetInitial) && bReplicateMovement) && ((RemoteRole == ROLE_AutonomousProxy) && bNetInitial) || ((RemoteRole == ROLE_SimulatedProxy) && bNetInitial || bUpdateSimulatedPosition) && (Base == none) || Base.bWorldGeometry)
        Location, Rotation

    // Pos:0x0B8
    if(((!bSkipActorPropertyReplication || bNetInitial) && bReplicateMovement) && RemoteRole == ROLE_SimulatedProxy)
        Base

    // Pos:0x0F8
    if((((((!bSkipActorPropertyReplication || bNetInitial) && bReplicateMovement) && bNetInitial || bUpdateSimulatedPosition) && RemoteRole == ROLE_SimulatedProxy) && Base != none) && !Base.bWorldGeometry)
        RelativeLocation, RelativeRotation

    // Pos:0x18D
    if(((!bSkipActorPropertyReplication || bNetInitial) && bReplicateMovement) && (RemoteRole == ROLE_SimulatedProxy) && bNetInitial || bUpdateSimulatedPosition)
        Physics, Velocity

    // Pos:0x1EB
    if((!bSkipActorPropertyReplication || bNetInitial) && Role == ROLE_Authority)
        bHardAttach

    // Pos:0x21C
    if(((!bSkipActorPropertyReplication || bNetInitial) && Role == ROLE_Authority) && bNetDirty)
        bHidden

    // Pos:0x25C
    if((((!bSkipActorPropertyReplication || bNetInitial) && Role == ROLE_Authority) && bNetDirty) && bCollideActors || bCollideWorld)
        bBlockActors, bProjTarget

    // Pos:0x2BA
    if((!bSkipActorPropertyReplication || bNetInitial) && Role == ROLE_Authority)
        RemoteRole, Role, 
        bNetOwner, bTearOff

    // Pos:0x2EB
    if((((!bSkipActorPropertyReplication || bNetInitial) && Role == ROLE_Authority) && bNetDirty) && bReplicateInstigator)
        Instigator

    // Pos:0x33A
    if(((!bSkipActorPropertyReplication || bNetInitial) && Role == ROLE_Authority) && bNetDirty)
        DrawScale, ReplicatedCollisionType, 
        bCollideActors, bCollideWorld

    // Pos:0x37A
    if(((bNetOwner && !bSkipActorPropertyReplication || bNetInitial) && Role == ROLE_Authority) && bNetDirty)
        Owner
}

// Export UActor::execForceUpdateComponents(FFrame&, void* const)
native function ForceUpdateComponents(optional bool bCollisionUpdate, optional bool bTransformOnly)
{
    bCollisionUpdate = false;
    bTransformOnly = true;                
}

// Export UActor::execConsoleCommand(FFrame&, void* const)
native function string ConsoleCommand(string Command, optional bool bWriteToLog)
{
    bWriteToLog = true;                
}

// Export UActor::execSleep(FFrame&, void* const)
native(256) final latent function Sleep(float Seconds);

// Export UActor::execFinishAnim(FFrame&, void* const)
native(261) final latent function FinishAnim(AnimNodeSequence SeqNode, optional bool bFinishOnBlendOut);

// Export UActor::execSetCollision(FFrame&, void* const)
native(262) final function SetCollision(optional bool bNewColActors, optional bool bNewBlockActors, optional bool bNewIgnoreEncroachers);

// Export UActor::execSetCollisionSize(FFrame&, void* const)
native(283) final function SetCollisionSize(float NewRadius, float NewHeight);

// Export UActor::execSetCollisionType(FFrame&, void* const)
native final function SetCollisionType(Actor.ECollisionType NewCollisionType);

// Export UActor::execSetDrawScale(FFrame&, void* const)
native final function SetDrawScale(float NewScale);

// Export UActor::execSetDrawScale3D(FFrame&, void* const)
native final function SetDrawScale3D(Vector NewScale3D);

// Export UActor::execMove(FFrame&, void* const)
native(266) final function bool Move(Vector Delta);

// Export UActor::execSetLocation(FFrame&, void* const)
native(267) final function bool SetLocation(Vector NewLocation);

// Export UActor::execSetRotation(FFrame&, void* const)
native(299) final function bool SetRotation(Rotator NewRotation);

// Export UActor::execMovingWhichWay(FFrame&, void* const)
native function Actor.EMoveDir MovingWhichWay(out float Amount);

// Export UActor::execSetZone(FFrame&, void* const)
native final function SetZone(bool bForceRefresh);

// Export UActor::execSetRelativeRotation(FFrame&, void* const)
native final function bool SetRelativeRotation(Rotator NewRotation);

// Export UActor::execSetRelativeLocation(FFrame&, void* const)
native final function bool SetRelativeLocation(Vector NewLocation);

// Export UActor::execSetHardAttach(FFrame&, void* const)
native final function SetHardAttach(optional bool bNewHardAttach);

// Export UActor::execSetShadowParentOnAllAttachedComponents(FFrame&, void* const)
native simulated function SetShadowParentOnAllAttachedComponents(PrimitiveComponent MyPrimComp, LightEnvironmentComponent MyLightEnv);

// Export UActor::execfixedTurn(FFrame&, void* const)
native final function int fixedTurn(int Current, int Desired, int DeltaRate);

// Export UActor::execMoveSmooth(FFrame&, void* const)
native(3969) final function bool MoveSmooth(Vector Delta);

// Export UActor::execAutonomousPhysics(FFrame&, void* const)
native(3971) final function AutonomousPhysics(float DeltaSeconds);

// Export UActor::execGetTerminalVelocity(FFrame&, void* const)
native function float GetTerminalVelocity();

// Export UActor::execSetBase(FFrame&, void* const)
native(298) final function SetBase(Actor NewBase, optional Vector NewFloor, optional SkeletalMeshComponent SkelComp, optional name AttachName);

// Export UActor::execSetOwner(FFrame&, void* const)
native(272) final function SetOwner(Actor NewOwner);

// Export UActor::execFindBase(FFrame&, void* const)
native function FindBase();

// Export UActor::execSearchForBaseBelow(FFrame&, void* const)
native function SearchForBaseBelow(float HeightBelow, out Actor NewBase, out Vector HitNormal);

// Export UActor::execIsBasedOn(FFrame&, void* const)
native final function bool IsBasedOn(Actor TestActor);

// Export UActor::execGetBaseMost(FFrame&, void* const)
native function Actor GetBaseMost();

// Export UActor::execIsOwnedBy(FFrame&, void* const)
native final function bool IsOwnedBy(Actor TestActor);

// Export UActor::execGetAggregateBaseVelocity(FFrame&, void* const)
native final function Vector GetAggregateBaseVelocity(optional Actor TestBase);

simulated event ReplicatedEvent(name VarName)
{
    //return;    
}

// Export UActor::execSetForcedInitialReplicatedProperty(FFrame&, void* const)
native final function SetForcedInitialReplicatedProperty(Property PropToReplicate, bool bAdd);

// Export UActor::execVect2BP(FFrame&, void* const)
native static final function Vect2BP(out BasedPosition BP, Vector pos, optional Actor ForcedBase);

// Export UActor::execBP2Vect(FFrame&, void* const)
native static final function Vector BP2Vect(BasedPosition BP);

// Export UActor::execSetBasedPosition(FFrame&, void* const)
native static final function SetBasedPosition(out BasedPosition BP, Vector pos, optional Actor ForcedBase);

// Export UActor::execGetBasedPosition(FFrame&, void* const)
native static final function Vector GetBasedPosition(BasedPosition BP);

// Export UActor::execFlushPersistentDebugLines(FFrame&, void* const)
native static final function FlushPersistentDebugLines();

// Export UActor::execDrawDebugLine(FFrame&, void* const)
native static final function DrawDebugLine(Vector LineStart, Vector LineEnd, byte R, byte G, byte B, optional bool bPersistentLines);

// Export UActor::execDrawDebugPoint(FFrame&, void* const)
native static final function DrawDebugPoint(Vector Position, float Size, LinearColor PointColor, optional bool bPersistentLines);

// Export UActor::execDrawDebugBox(FFrame&, void* const)
native static final function DrawDebugBox(Vector Center, Vector Extent, byte R, byte G, byte B, optional bool bPersistentLines);

// Export UActor::execDrawDebugStar(FFrame&, void* const)
native static final function DrawDebugStar(Vector Position, float Size, byte R, byte G, byte B, optional bool bPersistentLines);

// Export UActor::execDrawDebugCoordinateSystem(FFrame&, void* const)
native static final function DrawDebugCoordinateSystem(Vector AxisLoc, Rotator AxisRot, float Scale, optional bool bPersistentLines);

// Export UActor::execDrawDebugSphere(FFrame&, void* const)
native static final function DrawDebugSphere(Vector Center, float Radius, int Segments, byte R, byte G, byte B, optional bool bPersistentLines);

// Export UActor::execDrawDebugCylinder(FFrame&, void* const)
native static final function DrawDebugCylinder(Vector Start, Vector End, float Radius, int Segments, byte R, byte G, byte B, optional bool bPersistentLines);

// Export UActor::execDrawDebugCone(FFrame&, void* const)
native static final function DrawDebugCone(Vector Origin, Vector Direction, float Length, float AngleWidth, float AngleHeight, int NumSides, Color DrawColor, optional bool bPersistentLines);

// Export UActor::execDrawDebugString(FFrame&, void* const)
native static final function DrawDebugString(Vector TextLocation, coerce string Text, optional Actor TestBaseActor, optional Color TextColor, optional float Duration)
{
    Duration = -1.0;                            
}

// Export UActor::execDrawDebugFrustrum(FFrame&, void* const)
native static final function DrawDebugFrustrum(const out Matrix FrustumToWorld, byte R, byte G, byte B, optional bool bPersistentLines);

// Export UActor::execFlushDebugStrings(FFrame&, void* const)
native static final exec function FlushDebugStrings();

// Export UActor::execChartData(FFrame&, void* const)
native final function ChartData(string DataName, float DataValue);

// Export UActor::execSetHidden(FFrame&, void* const)
native final function SetHidden(bool bNewHidden);

// Export UActor::execSetHiddenComponent(FFrame&, void* const)
native final function SetHiddenComponent(bool bNewHidden, Class pClass);

// Export UActor::execSetOnlyOwnerSee(FFrame&, void* const)
native final function SetOnlyOwnerSee(bool bNewOnlyOwnerSee);

// Export UActor::execSetPhysics(FFrame&, void* const)
native(3970) final function SetPhysics(Actor.EPhysics newPhysics);

// Export UActor::execClock(FFrame&, void* const)
native final function Clock(out float Time);

// Export UActor::execUnClock(FFrame&, void* const)
native final function UnClock(out float Time);

// Export UActor::execAttachComponent(FFrame&, void* const)
native final function AttachComponent(ActorComponent NewComponent);

// Export UActor::execDetachComponent(FFrame&, void* const)
native final function DetachComponent(ActorComponent ExComponent);

// Export UActor::execReattachComponent(FFrame&, void* const)
native final function ReattachComponent(ActorComponent ComponentToReattach);

// Export UActor::execSetTickGroup(FFrame&, void* const)
native final function SetTickGroup(Core.Object.ETickingGroup NewTickGroup);

// Export UActor::execSetTickIsDisabled(FFrame&, void* const)
native final function SetTickIsDisabled(bool bInDisabled);

event Destroyed()
{
    //return;    
}

event GainedChild(Actor Other)
{
    //return;    
}

event LostChild(Actor Other)
{
    //return;    
}

event Tick(float DeltaTime)
{
    //return;    
}

event Timer()
{
    //return;    
}

event HitWall(Vector HitNormal, Actor Wall, PrimitiveComponent WallComp)
{
    TriggerEventClass(class'SeqEvent_HitWall', Wall);
    //return;    
}

event Falling()
{
    //return;    
}

event Landed(Vector HitNormal, Actor FloorActor)
{
    //return;    
}

event PhysicsVolumeChange(PhysicsVolume NewVolume)
{
    //return;    
}

event Touch(Actor Other, PrimitiveComponent OtherComp, Vector HitLocation, Vector HitNormal)
{
    //return;    
}

event PostTouch(Actor Other)
{
    //return;    
}

event UnTouch(Actor Other)
{
    //return;    
}

event Bump(Actor Other, PrimitiveComponent OtherComp, Vector HitNormal)
{
    //return;    
}

event BaseChange()
{
    //return;    
}

event Attach(Actor Other)
{
    //return;    
}

event Detach(Actor Other)
{
    //return;    
}

event Actor SpecialHandling(Pawn Other)
{
    //return ReturnValue;    
}

event CollisionChanged()
{
    //return;    
}

event bool EncroachingOn(Actor Other)
{
    //return ReturnValue;    
}

event EncroachedBy(Actor Other)
{
    //return;    
}

event RanInto(Actor Other)
{
    //return;    
}

event OnWakeRBPhysics()
{
    //return;    
}

event OnSleepRBPhysics()
{
    //return;    
}

// Export UActor::execClampRotation(FFrame&, void* const)
native final simulated function bool ClampRotation(out Rotator out_Rot, Rotator rBase, Rotator rUpperLimits, Rotator rLowerLimits);

simulated event bool OverRotated(out Rotator out_Desired, out Rotator out_Actual)
{
    //return ReturnValue;    
}

function bool UsedBy(Pawn User)
{
    return TriggerEventClass(class'SeqEvent_Used', User, -1);
    //return ReturnValue;    
}

simulated event FellOutOfWorld(class<DamageType> dmgType)
{
    SetPhysics(0);
    SetHidden(true);
    SetCollision(false, false);
    Destroy();
    //return;    
}

simulated event OutsideWorldBounds()
{
    Destroy();
    //return;    
}

simulated function VolumeBasedDestroy(PhysicsVolume PV)
{
    Destroy();
    //return;    
}

// Export UActor::execTrace(FFrame&, void* const)
native(277) final function Actor Trace(out Vector HitLocation, out Vector HitNormal, Vector TraceEnd, optional Vector TraceStart, optional bool bTraceActors, optional Vector Extent, optional out TraceHitInfo HitInfo, optional int ExtraTraceFlags);

// Export UActor::execTraceComponent(FFrame&, void* const)
native final function bool TraceComponent(out Vector HitLocation, out Vector HitNormal, PrimitiveComponent InComponent, Vector TraceEnd, optional Vector TraceStart, optional Vector Extent, optional out TraceHitInfo HitInfo, optional bool bComplexCollision);

// Export UActor::execPointCheckComponent(FFrame&, void* const)
native final function bool PointCheckComponent(PrimitiveComponent InComponent, Vector PointLocation, Vector PointExtent);

// Export UActor::execFastTrace(FFrame&, void* const)
native(548) final function bool FastTrace(Vector TraceEnd, optional Vector TraceStart, optional Vector BoxExtent, optional bool bTraceBullet);

// Export UActor::execTraceAllPhysicsAssetInteractions(FFrame&, void* const)
native final function bool TraceAllPhysicsAssetInteractions(SkeletalMeshComponent SkelMeshComp, Vector EndTrace, Vector StartTrace, out array<ImpactInfo> out_Hits, optional Vector Extent);

// Export UActor::execFindSpot(FFrame&, void* const)
native final function bool FindSpot(Vector BoxExtent, out Vector SpotLocation);

// Export UActor::execContainsPoint(FFrame&, void* const)
native final function bool ContainsPoint(Vector Spot);

// Export UActor::execIsOverlapping(FFrame&, void* const)
native final function bool IsOverlapping(Actor A);

// Export UActor::execGetComponentsBoundingBox(FFrame&, void* const)
native final function GetComponentsBoundingBox(out Box ActorBox);

// Export UActor::execGetBoundingCylinder(FFrame&, void* const)
native function GetBoundingCylinder(out float CollisionRadius, out float CollisionHeight);

// Export UActor::execIsBlockedBy(FFrame&, void* const)
native final function bool IsBlockedBy(const Actor Other);

// Export UActor::execSpawn(FFrame&, void* const)
native final function Actor Spawn(class<Actor> SpawnClass, optional Actor SpawnOwner, optional name SpawnTag, optional Vector SpawnLocation, optional Rotator SpawnRotation, optional Actor ActorTemplate, optional bool bNoCollisionFail);

// Export UActor::execDestroy(FFrame&, void* const)
native(279) final function bool Destroy();

event TornOff()
{
    //return;    
}

// Export UActor::execSetTimer(FFrame&, void* const)
native(280) final function SetTimer(float InRate, optional bool inbLoop, optional name inTimerFunc, optional Object inObj)
{
    inTimerFunc = 'Timer';                            
}

// Export UActor::execClearTimer(FFrame&, void* const)
native final function ClearTimer(optional name inTimerFunc, optional Object inObj)
{
    inTimerFunc = 'Timer';                    
}

// Export UActor::execClearAllTimers(FFrame&, void* const)
native final function ClearAllTimers(optional Object inObj);

// Export UActor::execPauseTimer(FFrame&, void* const)
native final function PauseTimer(bool bPause, optional name inTimerFunc, optional Object inObj)
{
    inTimerFunc = 'Timer';                        
}

// Export UActor::execIsTimerActive(FFrame&, void* const)
native final function bool IsTimerActive(optional name inTimerFunc, optional Object inObj)
{
    inTimerFunc = 'Timer';                    
}

// Export UActor::execGetTimerCount(FFrame&, void* const)
native final function float GetTimerCount(optional name inTimerFunc, optional Object inObj)
{
    inTimerFunc = 'Timer';                    
}

// Export UActor::execGetTimerRate(FFrame&, void* const)
native final function float GetTimerRate(optional name TimerFuncName, optional Object inObj)
{
    TimerFuncName = 'Timer';                    
}

final simulated function float GetRemainingTimeForTimer(optional name TimerFuncName, optional Object inObj)
{
    local float Count, Rate;

    TimerFuncName = 'Timer';    
    Rate = GetTimerRate(TimerFuncName, inObj);
    // End:0x82
    if(Rate != -1.0)
    {
        Count = GetTimerCount(TimerFuncName, inObj);
        return Rate - Count;
    }
    return -1.0;
    //return ReturnValue;    
}

// Export UActor::execModifyTimerTimeDilation(FFrame&, void* const)
native final function ModifyTimerTimeDilation(const name TimerName, const float InTimerTimeDilation, optional Object inObj);

// Export UActor::execResetTimerTimeDilation(FFrame&, void* const)
native final function ResetTimerTimeDilation(const name TimerName, optional Object inObj);

// Export UActor::execCreateAudioComponent(FFrame&, void* const)
native final function AudioComponent CreateAudioComponent(SoundCue InSoundCue, optional bool bPlay, optional bool bStopWhenOwnerDestroyed, optional bool bUseLocation, optional Vector SourceLocation, optional bool bAttachToSelf)
{
    bAttachToSelf = true;                                
}

// Export UActor::execPlaySound(FFrame&, void* const)
native final function PlaySound(SoundCue InSoundCue, optional bool bNotReplicated, optional bool bNoRepToOwner, optional bool bStopWhenOwnerDestroyed, optional Vector SoundLocation, optional bool bNoRepToRelevant);

// Export UActor::execMakeNoise(FFrame&, void* const)
native(512) final function MakeNoise(float Loudness, optional name NoiseType);

// Export UActor::execPlayerCanSeeMe(FFrame&, void* const)
native(532) final function bool PlayerCanSeeMe(optional bool bForceLOSCheck);

// Export UActor::execSuggestTossVelocity(FFrame&, void* const)
native final function bool SuggestTossVelocity(out Vector TossVelocity, Vector Destination, Vector Start, float TossSpeed, optional float BaseTossZ, optional float DesiredZPct, optional Vector CollisionSize, optional float TerminalVelocity, optional float OverrideGravityZ, optional bool bOnlyTraceUp);

// Export UActor::execCalculateMinSpeedTrajectory(FFrame&, void* const)
native final function bool CalculateMinSpeedTrajectory(out Vector out_Velocity, Vector End, Vector Start, float MaxTossSpeed, float MinTossSpeed, optional Vector CollisionSize, optional float TerminalVelocity, optional float GravityZ, optional bool bOnlyTraceUp)
{
    GravityZ = GetGravityZ();                                                
}

// Export UActor::execGetDestination(FFrame&, void* const)
native final function Vector GetDestination(Controller C);

function bool PreTeleport(Teleporter InTeleporter)
{
    //return ReturnValue;    
}

function PostTeleport(Teleporter OutTeleporter)
{
    //return;    
}

// Export UActor::execGetURLMap(FFrame&, void* const)
native(547) final function string GetURLMap();

// Export UActor::execAllActors(FFrame&, void* const)
native(304) final iterator function AllActors(class<Actor> BaseClass, out Actor Actor, optional class<Interface> InterfaceClass);

// Export UActor::execDynamicActors(FFrame&, void* const)
native(313) final iterator function DynamicActors(class<Actor> BaseClass, out Actor Actor, optional class<Interface> InterfaceClass);

// Export UActor::execChildActors(FFrame&, void* const)
native(305) final iterator function ChildActors(class<Actor> BaseClass, out Actor Actor);

// Export UActor::execBasedActors(FFrame&, void* const)
native(306) final iterator function BasedActors(class<Actor> BaseClass, out Actor Actor);

// Export UActor::execTouchingActors(FFrame&, void* const)
native(307) final iterator function TouchingActors(class<Actor> BaseClass, out Actor Actor);

// Export UActor::execTraceActors(FFrame&, void* const)
native(309) final iterator function TraceActors(class<Actor> BaseClass, out Actor Actor, out Vector HitLoc, out Vector HitNorm, Vector End, optional Vector Start, optional Vector Extent, optional out TraceHitInfo HitInfo, optional int ExtraTraceFlags);

// Export UActor::execVisibleActors(FFrame&, void* const)
native(311) final iterator function VisibleActors(class<Actor> BaseClass, out Actor Actor, optional float Radius, optional Vector Loc);

// Export UActor::execVisibleCollidingActors(FFrame&, void* const)
native(312) final iterator function VisibleCollidingActors(class<Actor> BaseClass, out Actor Actor, float Radius, optional Vector Loc, optional bool bIgnoreHidden, optional Vector Extent, optional bool bTraceActors, optional class<Interface> InterfaceClass, optional out TraceHitInfo HitInfo);

// Export UActor::execCollidingActors(FFrame&, void* const)
native(321) final iterator function CollidingActors(class<Actor> BaseClass, out Actor Actor, float Radius, optional Vector Loc, optional bool bUseOverlapCheck, optional class<Interface> InterfaceClass, optional out TraceHitInfo HitInfo);

// Export UActor::execOverlappingActors(FFrame&, void* const)
native final iterator function OverlappingActors(class<Actor> BaseClass, out Actor out_Actor, float Radius, optional Vector Loc, optional bool bIgnoreHidden);

// Export UActor::execComponentList(FFrame&, void* const)
native final iterator function ComponentList(class<ActorComponent> BaseClass, out ActorComponent out_Component);

// Export UActor::execAllOwnedComponents(FFrame&, void* const)
native final iterator function AllOwnedComponents(class<Component> BaseClass, out ActorComponent OutComponent);

// Export UActor::execLocalPlayerControllers(FFrame&, void* const)
native final iterator function LocalPlayerControllers(class<PlayerController> BaseClass, out PlayerController PC);

// Export UActor::execGetALocalPlayerController(FFrame&, void* const)
native final function PlayerController GetALocalPlayerController();

event PreBeginPlay()
{
    // End:0xA4
    if(((!bGameRelevant && !bStatic) && WorldInfo.NetMode != NM_Client) && !WorldInfo.Game.CheckRelevance(self))
    {
        // End:0xA1
        if(bNoDelete)
        {
            ShutDown();
        }
        // End:0xA4
        else
        {
            Destroy();
        }
    }
    //return;    
}

event BroadcastLocalizedMessage(class<LocalMessage> InMessageClass, optional int Switch, optional PlayerReplicationInfo RelatedPRI_1, optional PlayerReplicationInfo RelatedPRI_2, optional Object OptionalObject)
{
    WorldInfo.Game.BroadcastLocalized(self, InMessageClass, Switch, RelatedPRI_1, RelatedPRI_2, OptionalObject);
    //return;    
}

event BroadcastLocalizedTeamMessage(int TeamIndex, class<LocalMessage> InMessageClass, optional int Switch, optional PlayerReplicationInfo RelatedPRI_1, optional PlayerReplicationInfo RelatedPRI_2, optional Object OptionalObject)
{
    WorldInfo.Game.BroadcastLocalizedTeam(TeamIndex, self, InMessageClass, Switch, RelatedPRI_1, RelatedPRI_2, OptionalObject);
    //return;    
}

event PostBeginPlay()
{
    //return;    
}

simulated event SetInitialState()
{
    bScriptInitialized = true;
    // End:0x34
    if(InitialState != 'None')
    {
        GotoState(InitialState);
    }
    // End:0x42
    else
    {
        GotoState('Auto');
    }
    //return;    
}

simulated event ConstraintBrokenNotify(Actor ConOwner, RB_ConstraintSetup ConSetup, RB_ConstraintInstance ConInstance)
{
    //return;    
}

simulated event NotifySkelControlBeyondLimit(SkelControlLookAt LookAt)
{
    //return;    
}

simulated function bool StopsProjectile(Projectile P)
{
    return bProjTarget || bBlockActors;
    //return ReturnValue;    
}

simulated function bool HurtRadius(float BaseDamage, float DamageRadius, class<DamageType> DamageType, float Momentum, Vector HurtOrigin, optional Actor IgnoredActor, optional Controller InstigatedByController, optional bool bDoFullDamage)
{
    local Actor Victim;
    local bool bCausedDamage;
    local TraceHitInfo HitInfo;
    local editinline StaticMeshComponent HitComponent;
    local KActorFromStatic NewKActor;

    InstigatedByController = ((Instigator != none) ? Instigator.Controller : none);    
    // End:0x45
    if(bHurtEntry)
    {
        return false;
    }
    bHurtEntry = true;
    bCausedDamage = false;
    // End:0x29D
    foreach VisibleCollidingActors(class'Actor', Victim, DamageRadius, HurtOrigin,,,,, HitInfo)
    {
        // End:0x16C
        if(Victim.bWorldGeometry)
        {
            HitComponent = StaticMeshComponent(HitInfo.HitComponent);
            // End:0x16C
            if((HitComponent != none) && HitComponent.CanBecomeDynamic())
            {
                NewKActor = class'KActorFromStatic'.static.MakeDynamic(HitComponent);
                // End:0x16C
                if(NewKActor != none)
                {
                    Victim = NewKActor;
                }
            }
        }
        // End:0x29C
        if(((!Victim.bWorldGeometry && Victim != self) && Victim != IgnoredActor) && Victim.bCanBeDamaged || Victim.bProjTarget)
        {
            Victim.TakeRadiusDamage(InstigatedByController, BaseDamage, DamageRadius, DamageType, Momentum, HurtOrigin, bDoFullDamage, self);
            bCausedDamage = bCausedDamage || Victim.bProjTarget;
        }        
    }    
    bHurtEntry = false;
    return bCausedDamage;
    //return ReturnValue;    
}

function KilledBy(Pawn EventInstigator)
{
    //return;    
}

event TakeDamage(int DamageAmount, Controller EventInstigator, Vector HitLocation, Vector Momentum, class<DamageType> DamageType, optional TraceHitInfo HitInfo, optional Actor DamageCauser)
{
    local int Idx;
    local SeqEvent_TakeDamage dmgEvent;

    Idx = 0;
    J0x0D:
    // End:0xA3 [Loop If]
    if(Idx < GeneratedEvents.Length)
    {
        dmgEvent = SeqEvent_TakeDamage(GeneratedEvents[Idx]);
        // End:0x95
        if(dmgEvent != none)
        {
            dmgEvent.HandleDamage(self, EventInstigator, DamageType, DamageAmount);
        }
        ++ Idx;
        // [Loop Continue]
        goto J0x0D;
    }
    //return;    
}

event bool HealDamage(int Amount, Controller Healer, class<DamageType> DamageType)
{
    //return ReturnValue;    
}

simulated function TakeRadiusDamage(Controller InstigatedBy, float BaseDamage, float DamageRadius, class<DamageType> DamageType, float Momentum, Vector HurtOrigin, bool bFullDamage, Actor DamageCauser, optional float DamageFalloffExponent)
{
    local float ColRadius, ColHeight, DamageScale, Dist, ScaledDamage;

    local Vector Dir;

    DamageFalloffExponent = 1.0;
    GetBoundingCylinder(ColRadius, ColHeight);
    Dir = Location - HurtOrigin;
    Dist = VSize(Dir);
    Dir = Normal(Dir);
    // End:0x8C
    if(bFullDamage)
    {
        DamageScale = 1.0;
    }
    // End:0x100
    else
    {
        Dist = FMax(Dist - ColRadius, 0.0);
        DamageScale = FClamp(1.0 - (Dist / DamageRadius), 0.0, 1.0);
        DamageScale = DamageScale ** DamageFalloffExponent;
    }
    // End:0x1B2
    if(DamageScale > 0.0)
    {
        ScaledDamage = DamageScale * BaseDamage;
        TakeDamage(int(ScaledDamage), InstigatedBy, Location - ((0.50 * (ColHeight + ColRadius)) * Dir), (DamageScale * Momentum) * Dir, DamageType,, DamageCauser);
    }
    //return;    
}

final simulated function CheckHitInfo(out TraceHitInfo HitInfo, PrimitiveComponent FallBackComponent, Vector Dir, out Vector out_HitLocation)
{
    local Vector out_NewHitLocation, out_HitNormal, TraceEnd, TraceStart;
    local TraceHitInfo newHitInfo;

    // End:0x59
    if((SkeletalMeshComponent(HitInfo.HitComponent) != none) && HitInfo.BoneName != 'None')
    {
        return;
    }
    // End:0xE8
    if((HitInfo.HitComponent == none) || (SkeletalMeshComponent(HitInfo.HitComponent) == none) && SkeletalMeshComponent(FallBackComponent) != none)
    {
        HitInfo.HitComponent = FallBackComponent;
    }
    // End:0x2BA
    if((SkeletalMeshComponent(HitInfo.HitComponent) != none) && HitInfo.BoneName == 'None')
    {
        // End:0x163
        if(IsZero(Dir))
        {
            Dir = vector(Rotation);
        }
        // End:0x185
        if(IsZero(out_HitLocation))
        {
            out_HitLocation = Location;
        }
        TraceStart = out_HitLocation - (float(128) * Normal(Dir));
        TraceEnd = out_HitLocation + (float(128) * Normal(Dir));
        // End:0x2BA
        if(TraceComponent(out_NewHitLocation, out_HitNormal, HitInfo.HitComponent, TraceEnd, TraceStart, vect(0.0, 0.0, 0.0), newHitInfo))
        {
            HitInfo.BoneName = newHitInfo.BoneName;
            HitInfo.PhysMaterial = newHitInfo.PhysMaterial;
            out_HitLocation = out_NewHitLocation;
        }
    }
    //return;    
}

// Export UActor::execGetGravityZ(FFrame&, void* const)
native function float GetGravityZ();

event DebugFreezeGame(optional Actor ActorToLookAt)
{
    local PlayerController PC;

    ScriptTrace();
    PC = GetALocalPlayerController();
    // End:0x9C
    if(PC != none)
    {
        PC.ConsoleCommand("PlayersOnly");
        // End:0x9C
        if(ActorToLookAt != none)
        {
            PC.SetViewTarget(ActorToLookAt);
        }
    }
    //return;    
}

function bool CheckForErrors()
{
    //return ReturnValue;    
}

event BecomeViewTarget(PlayerController PC)
{
    //return;    
}

event EndViewTarget(PlayerController PC)
{
    //return;    
}

simulated function bool CalcCamera(float fDeltaTime, out Vector out_CamLoc, out Rotator out_CamRot, out float out_FOV)
{
    local Vector HitNormal;
    local float Radius, Height;

    GetBoundingCylinder(Radius, Height);
    // End:0x9F
    if(Trace(out_CamLoc, HitNormal, Location - ((vector(out_CamRot) * Radius) * float(20)), Location, false) == none)
    {
        out_CamLoc = Location - ((vector(out_CamRot) * Radius) * float(20));
    }
    // End:0xCA
    else
    {
        out_CamLoc = Location + (Height * vector(Rotation));
    }
    return false;
    //return ReturnValue;    
}

simulated function string GetItemName(string FullName)
{
    local int pos;

    pos = InStr(FullName, ".");
    J0x1B:
    // End:0x7A [Loop If]
    if(pos != -1)
    {
        FullName = Right(FullName, (Len(FullName) - pos) - 1);
        pos = InStr(FullName, ".");
        // [Loop Continue]
        goto J0x1B;
    }
    return FullName;
    //return ReturnValue;    
}

simulated function string GetHumanReadableName()
{
    return GetItemName(string(Class));
    //return ReturnValue;    
}

static function ReplaceText(out string Text, string Replace, string With)
{
    local int I;
    local string Input;

    Input = Text;
    Text = "";
    I = InStr(Input, Replace);
    J0x40:
    // End:0xD7 [Loop If]
    if(I != -1)
    {
        Text = (Text $ Left(Input, I)) $ With;
        Input = Mid(Input, I + Len(Replace));
        I = InStr(Input, Replace);
        // [Loop Continue]
        goto J0x40;
    }
    Text = Text $ Input;
    //return;    
}

static function string GetLocalString(optional int Switch, optional PlayerReplicationInfo RelatedPRI_1, optional PlayerReplicationInfo RelatedPRI_2)
{
    return "";
    //return ReturnValue;    
}

function MatchStarting()
{
    //return;    
}

function string GetDebugName()
{
    return GetItemName(string(self));
    //return ReturnValue;    
}

simulated function DisplayDebug(HUD HUD, out float out_YL, out float out_YPos)
{
    local string T;
    local Actor A;
    local float MyRadius, MyHeight;
    local Canvas Canvas;

    Canvas = HUD.Canvas;
    Canvas.SetPos(4.0, out_YPos);
    Canvas.SetDrawColor(255, 0, 0);
    T = GetDebugName();
    // End:0xD0
    if(bDeleteMe)
    {
        T = T $ " DELETED (bDeleteMe == true)";
    }
    // End:0x14F
    if(T != "")
    {
        Canvas.DrawText(T, false);
        out_YPos += out_YL;
        Canvas.SetPos(4.0, out_YPos);
    }
    Canvas.SetDrawColor(255, 255, 255);
    // End:0x2CC
    if(HUD.ShouldDisplayDebug('net'))
    {
        // End:0x2CC
        if(WorldInfo.NetMode != NM_Standalone)
        {
            T = (((("ROLE:" @ string(Role)) @ "RemoteRole:") @ string(RemoteRole)) @ "NetMode:") @ string(WorldInfo.NetMode);
            // End:0x25D
            if(bTearOff)
            {
                T = T @ "Tear Off";
            }
            Canvas.DrawText(T, false);
            out_YPos += out_YL;
            Canvas.SetPos(4.0, out_YPos);
        }
    }
    Canvas.DrawText((("Location:" @ string(Location)) @ "Rotation:") @ string(Rotation), false);
    out_YPos += out_YL;
    Canvas.SetPos(4.0, out_YPos);
    // End:0x6DD
    if(HUD.ShouldDisplayDebug('Physics'))
    {
        T = (((((("Physics" @ (GetPhysicsName())) @ "in physicsvolume") @ (GetItemName(string(PhysicsVolume)))) @ "on base") @ (GetItemName(string(Base)))) @ "gravity") @ string(GetGravityZ());
        // End:0x446
        if(bBounce)
        {
            T = T $ " - will bounce";
        }
        Canvas.DrawText(T, false);
        out_YPos += out_YL;
        Canvas.SetPos(4.0, out_YPos);
        Canvas.DrawText((((((((("bHardAttach:" @ string(bHardAttach)) @ "RelativeLoc:") @ string(RelativeLocation)) @ "RelativeRot:") @ string(RelativeRotation)) @ "SkelComp:") @ string(BaseSkelComponent)) @ "Bone:") @ string(BaseBoneName), false);
        out_YPos += out_YL;
        Canvas.SetPos(4.0, out_YPos);
        Canvas.DrawText((((("Velocity:" @ string(Velocity)) @ "Speed:") @ string(VSize(Velocity))) @ "Speed2D:") @ string(VSize2D(Velocity)), false);
        out_YPos += out_YL;
        Canvas.SetPos(4.0, out_YPos);
        Canvas.DrawText("Acceleration:" @ string(Acceleration), false);
        out_YPos += out_YL;
        Canvas.SetPos(4.0, out_YPos);
    }
    // End:0xA3F
    if(HUD.ShouldDisplayDebug('Collision'))
    {
        Canvas.DrawColor.B = 0;
        GetBoundingCylinder(MyRadius, MyHeight);
        Canvas.DrawText((("Collision Radius:" @ string(MyRadius)) @ "Height:") @ string(MyHeight));
        out_YPos += out_YL;
        Canvas.SetPos(4.0, out_YPos);
        Canvas.DrawText((((("Collides with Actors:" @ string(bCollideActors)) @ " world:") @ string(bCollideWorld)) @ "proj. target:") @ string(bProjTarget));
        out_YPos += out_YL;
        Canvas.SetPos(4.0, out_YPos);
        Canvas.DrawText("Blocks Actors:" @ string(bBlockActors));
        out_YPos += out_YL;
        Canvas.SetPos(4.0, out_YPos);
        T = "Touching ";
        // End:0x99A
        foreach TouchingActors(class'Actor', A)
        {
            T = (T $ (GetItemName(string(A)))) $ " ";            
        }        
        // End:0x9D0
        if(T == "Touching ")
        {
            T = "Touching nothing";
        }
        Canvas.DrawText(T, false);
        out_YPos += out_YL;
        Canvas.SetPos(4.0, out_YPos);
    }
    Canvas.DrawColor.B = 255;
    Canvas.DrawText(" STATE:" @ string(GetStateName()), false);
    out_YPos += out_YL;
    Canvas.SetPos(4.0, out_YPos);
    Canvas.DrawText(((" Instigator:" @ (GetItemName(string(Instigator)))) @ "Owner:") @ (GetItemName(string(Owner))));
    out_YPos += out_YL;
    Canvas.SetPos(4.0, out_YPos);
    //return;    
}

simulated function string GetPhysicsName()
{
    switch(Physics)
    {
        // End:0x22
        case 0:
            return "None";
            // End:0x105
            break;
        // End:0x34
        case 1:
            return "Walking";
            // End:0x105
            break;
        // End:0x46
        case 2:
            return "Falling";
            // End:0x105
            break;
        // End:0x59
        case 3:
            return "Swimming";
            // End:0x105
            break;
        // End:0x6A
        case 4:
            return "Flying";
            // End:0x105
            break;
        // End:0x7D
        case 5:
            return "Rotating";
            // End:0x105
            break;
        // End:0x92
        case 6:
            return "Projectile";
            // End:0x105
            break;
        // End:0xAA
        case 7:
            return "Interpolating";
            // End:0x105
            break;
        // End:0xBB
        case 8:
            return "Spider";
            // End:0x105
            break;
        // End:0xCC
        case 9:
            return "Ladder";
            // End:0x105
            break;
        // End:0xE0
        case 10:
            return "RigidBody";
            // End:0x105
            break;
        // End:0xF1
        case 13:
            return "Unused";
            // End:0x105
            break;
        // End:0x102
        case 14:
            return "Custom";
            // End:0x105
            break;
        // End:0xFFFF
        default:
            return "Unknown";
    }
    //return ReturnValue;    
}

simulated event ModifyHearSoundComponent(AudioComponent AC)
{
    //return;    
}

simulated event AudioComponent GetFaceFXAudioComponent()
{
    return none;
    //return ReturnValue;    
}

event Reset()
{
    //return;    
}

function bool IsInPain()
{
    local PhysicsVolume V;

    // End:0x66
    foreach TouchingActors(class'PhysicsVolume', V)
    {
        // End:0x65
        if(V.bPainCausing && V.DamagePerSec > float(0))
        {            
            return true;
        }        
    }    
    return false;
    //return ReturnValue;    
}

function PlayTeleportEffect(bool bOut, bool bSound)
{
    //return;    
}

simulated function bool CanSplash()
{
    return false;
    //return ReturnValue;    
}

simulated function ApplyFluidSurfaceImpact(FluidSurfaceActor Fluid, Vector HitLocation)
{
    local float Radius, Height, AdjustedVelocity;

    // End:0xE4
    if(bAllowFluidSurfaceInteraction)
    {
        AdjustedVelocity = 0.010 * Abs(Velocity.Z);
        GetBoundingCylinder(Radius, Height);
        Fluid.FluidComponent.ApplyForce(HitLocation, AdjustedVelocity * Fluid.FluidComponent.ForceImpact, Radius * 0.30, true);
    }
    //return;    
}

simulated function bool EffectIsRelevant(Vector SpawnLocation, bool bForceDedicated, optional float VisibleCullDistance, optional float HiddenCullDistance)
{
    VisibleCullDistance = 5000.0;
    HiddenCullDistance = 350.0;
    // End:0x5C
    if(SpawnLocation == Location)
    {
        return ActorEffectIsRelevant(Instigator, bForceDedicated, VisibleCullDistance, HiddenCullDistance);
    }
    // End:0x96
    else
    {
        return ImpactEffectIsRelevant(Instigator, SpawnLocation, bForceDedicated, VisibleCullDistance, HiddenCullDistance);
    }
    //return ReturnValue;    
}

simulated function bool ActorEffectIsRelevant(Pawn EffectInstigator, bool bForceDedicated, optional float VisibleCullDistance, optional float HiddenCullDistance)
{
    local PlayerController P;
    local float DistSq;
    local Vector CameraLoc;
    local Rotator CameraRot;

    VisibleCullDistance = 5000.0;
    HiddenCullDistance = 350.0;
    // End:0x98
    if(WorldInfo.NetMode == NM_DedicatedServer)
    {
        // End:0x8D
        if(bDebugEffectIsRelevant && bForceDedicated)
        {
            DebugMessagePlayer("EffectIsRelevant FAILED - dedicated server");
        }
        return bForceDedicated;
    }
    // End:0x10D
    if((bForceDedicated && WorldInfo.NetMode == NM_ListenServer) && WorldInfo.Game.NumPlayers > 1)
    {
        return true;
    }
    // End:0x167
    if(((EffectInstigator != none) && EffectInstigator.IsHumanControlled()) && EffectInstigator.IsLocallyControlled())
    {
        return true;
    }
    DistSq = 10000000000.0;
    // End:0x23C
    foreach LocalPlayerControllers(class'PlayerController', P)
    {
        // End:0x1BD
        if(P.GetViewTarget() == self)
        {            
            return true;
        }
        P.GetPlayerViewPoint(CameraLoc, CameraRot);
        DistSq = FMin(DistSq, VSizeSq(Location - CameraLoc) * Square(P.LODDistanceFactor));        
    }    
    // End:0x2B0
    if(DistSq > (VisibleCullDistance * VisibleCullDistance))
    {
        // End:0x2AB
        if(bDebugEffectIsRelevant && true)
        {
            DebugMessagePlayer("EffectIsRelevant FAILED - VisibleCullDistance");
        }
        return false;
    }
    // End:0x2D4
    else
    {
        // End:0x2D4
        if(DistSq < (HiddenCullDistance * HiddenCullDistance))
        {
            return true;
        }
    }
    return (WorldInfo.TimeSeconds - LastRenderTime) < 0.30;
    //return ReturnValue;    
}

simulated function bool ImpactEffectIsRelevant(Pawn EffectInstigator, Vector SpawnLocation, bool bForceDedicated, optional float VisibleCullDistance, optional float HiddenCullDistance, optional bool bSkipLOSCheck)
{
    local PlayerController P;
    local float DistSq, InViewThreshold;
    local bool bIsInViewFrustrum;
    local Vector CameraLoc;
    local Rotator CameraRot;

    VisibleCullDistance = 5000.0;
    HiddenCullDistance = 350.0;    
    // End:0x99
    if(WorldInfo.NetMode == NM_DedicatedServer)
    {
        // End:0x8E
        if(bDebugEffectIsRelevant && bForceDedicated)
        {
            DebugMessagePlayer("EffectIsRelevant FAILED - dedicated server");
        }
        return bForceDedicated;
    }
    // End:0x10E
    if((bForceDedicated && WorldInfo.NetMode == NM_ListenServer) && WorldInfo.Game.NumPlayers > 1)
    {
        return true;
    }
    // End:0x168
    if(((EffectInstigator != none) && EffectInstigator.IsHumanControlled()) && EffectInstigator.IsLocallyControlled())
    {
        return true;
    }
    DistSq = 10000000000.0;
    // End:0x215
    foreach LocalPlayerControllers(class'PlayerController', P)
    {
        P.GetPlayerViewPoint(CameraLoc, CameraRot);
        DistSq = FMin(DistSq, VSizeSq(SpawnLocation - CameraLoc) * Square(P.LODDistanceFactor));        
    }    
    // End:0x289
    if(DistSq > (VisibleCullDistance * VisibleCullDistance))
    {
        // End:0x284
        if(bDebugEffectIsRelevant && true)
        {
            DebugMessagePlayer("EffectIsRelevant FAILED - VisibleCullDistance");
        }
        return false;
    }
    // End:0x2AD
    else
    {
        // End:0x2AD
        if(DistSq < (HiddenCullDistance * HiddenCullDistance))
        {
            return true;
        }
    }
    bIsInViewFrustrum = false;
    // End:0x3A5
    foreach LocalPlayerControllers(class'PlayerController', P)
    {
        P.GetPlayerViewPoint(CameraLoc, CameraRot);
        InViewThreshold = Cos(P.GetFOVAngle()) - 0.10;
        // End:0x3A4
        if((Normal(SpawnLocation - CameraLoc) Dot vector(CameraRot)) > InViewThreshold)
        {
            // End:0x3A4
            if(bSkipLOSCheck || FastTrace(SpawnLocation, CameraLoc))
            {
                bIsInViewFrustrum = true;
                // End:0x3A5
                break;
            }
        }        
    }    
    // End:0x3FD
    if(bDebugEffectIsRelevant && bIsInViewFrustrum)
    {
        DebugMessagePlayer("EffectIsRelevant FAILED - Outside View Frustrum");
    }
    return bIsInViewFrustrum;
    //return ReturnValue;    
}

final event DebugMessagePlayer(coerce string msg)
{
    local PlayerController PC;

    LogInternal(("!!!!" @ msg) @ "!!!!");
    ScriptTrace();
    // End:0x70
    foreach LocalPlayerControllers(class'PlayerController', PC)
    {
        PC.ClientMessage(msg);        
    }    
    //return;    
}

simulated function bool TriggerEventClass(class<SequenceEvent> InEventClass, Actor InInstigator, optional int ActivateIndex, optional bool bTest, optional out array<SequenceEvent> ActivatedEvents)
{
    local array<int> ActivateIndices;

    ActivateIndex = -1;        
    // End:0x2F
    if(ActivateIndex >= 0)
    {
        ActivateIndices[0] = ActivateIndex;
    }
    return ActivateEventClass(InEventClass, InInstigator, GeneratedEvents, ActivateIndices, bTest, ActivatedEvents);
    //return ReturnValue;    
}

simulated event ReceivedNewEvent(SequenceEvent Evt)
{
    //return;    
}

simulated function bool TriggerGlobalEventClass(class<SequenceEvent> InEventClass, Actor InInstigator, optional int ActivateIndex)
{
    local array<SequenceObject> EventsToActivate;
    local array<int> ActivateIndices;
    local Sequence GameSeq;
    local bool bResult;
    local int I;

    ActivateIndex = -1;
    // End:0x2D
    if(ActivateIndex >= 0)
    {
        ActivateIndices[0] = ActivateIndex;
    }
    GameSeq = WorldInfo.GetGameSequence();
    // End:0x11E
    if(GameSeq != none)
    {
        GameSeq.FindSeqObjectsByClass(InEventClass, true, EventsToActivate);
        I = 0;
        J0xA2:
        // End:0x11E [Loop If]
        if(I < EventsToActivate.Length)
        {
            // End:0x110
            if(SequenceEvent(EventsToActivate[I]).CheckActivate(self, InInstigator,, ActivateIndices))
            {
                bResult = true;
            }
            ++ I;
            // [Loop Continue]
            goto J0xA2;
        }
    }
    return bResult;
    //return ReturnValue;    
}

final simulated function bool ActivateEventClass(class<SequenceEvent> InClass, Actor InInstigator, const out array<SequenceEvent> EventList, const optional out array<int> ActivateIndices, optional bool bTest, optional out array<SequenceEvent> ActivatedEvents)
{
    local SequenceEvent Evt;

    ActivatedEvents.Length = 0;
    // End:0xAC
    foreach EventList(Evt,)
    {
        // End:0xAB
        if(ClassIsChildOf(Evt.Class, InClass) && Evt.CheckActivate(self, InInstigator, bTest, ActivateIndices))
        {
            ActivatedEvents.AddItem(Evt);
        }        
    }    
    return ActivatedEvents.Length > 0;
    //return ReturnValue;    
}

final simulated function bool FindEventsOfClass(class<SequenceEvent> EventClass, optional out array<SequenceEvent> out_EventList, optional bool bIncludeDisabled)
{
    local SequenceEvent Evt;
    local bool bFoundEvent;

    // End:0x116
    foreach GeneratedEvents(Evt,)
    {
        // End:0x115
        if((((Evt != none) && Evt.bEnabled || bIncludeDisabled) && ClassIsChildOf(Evt.Class, EventClass)) && (Evt.MaxTriggerCount == 0) || Evt.MaxTriggerCount > Evt.TriggerCount)
        {
            out_EventList.AddItem(Evt);
            bFoundEvent = true;
        }        
    }    
    return bFoundEvent;
    //return ReturnValue;    
}

final simulated function ClearLatentAction(class<SeqAct_Latent> actionClass, optional bool bAborted, optional SeqAct_Latent exceptionAction)
{
    local int Idx;

    Idx = 0;
    J0x0D:
    // End:0x10E [Loop If]
    if(Idx < LatentActions.Length)
    {
        // End:0x58
        if(LatentActions[Idx] == none)
        {
            LatentActions.Remove(-- Idx, 1);
        }
        // End:0x100
        else
        {
            // End:0x100
            if(ClassIsChildOf(LatentActions[Idx].Class, actionClass) && LatentActions[Idx] != exceptionAction)
            {
                // End:0xE9
                if(bAborted)
                {
                    LatentActions[Idx].AbortFor(self);
                }
                LatentActions.Remove(-- Idx, 1);
            }
        }
        ++ Idx;
        // [Loop Continue]
        goto J0x0D;
    }
    //return;    
}

simulated function OnDestroy(SeqAct_Destroy Action)
{
    local int AttachIdx, IgnoreIdx;
    local Actor A;

    // End:0x14A
    if(Action.bDestroyBasedActors)
    {
        AttachIdx = 0;
        J0x2D:
        // End:0x14A [Loop If]
        if(AttachIdx < Attached.Length)
        {
            A = Attached[AttachIdx];
            IgnoreIdx = 0;
            J0x6D:
            // End:0x102 [Loop If]
            if(IgnoreIdx < Action.IgnoreBasedClasses.Length)
            {
                // End:0xF4
                if(ClassIsChildOf(A.Class, Action.IgnoreBasedClasses[IgnoreIdx]))
                {
                    A = none;
                    // [Explicit Break]
                    goto J0x102;
                }
                ++ IgnoreIdx;
                J0x102:
                // [Loop Continue]
                goto J0x6D;
            }
            // End:0x114
            if(A == none)
            {
            }
            // End:0x13C
            else
            {
                A.OnDestroy(Action);
            }
            ++ AttachIdx;
            // [Loop Continue]
            goto J0x2D;
        }
    }
    // End:0x17A
    if(bNoDelete || Role < ROLE_Authority)
    {
        ShutDown();
    }
    // End:0x18C
    else
    {
        // End:0x18C
        if(!bDeleteMe)
        {
            Destroy();
        }
    }
    //return;    
}

event ForceNetRelevant()
{
    // End:0x5B
    if(((RemoteRole == ROLE_None) && bNoDelete) && !bStatic)
    {
        RemoteRole = ROLE_SimulatedProxy;
        bAlwaysRelevant = true;
        NetUpdateFrequency = 0.10;
    }
    bForceNetUpdate = true;
    //return;    
}

// Export UActor::execSetNetUpdateTime(FFrame&, void* const)
native final function SetNetUpdateTime(float NewUpdateTime);

simulated event ShutDown()
{
    SetPhysics(0);
    SetCollision(false, false);
    // End:0x3A
    if(CollisionComponent != none)
    {
        CollisionComponent.SetBlockRigidBody(false);
    }
    SetHidden(true);
    SetTickIsDisabled(true);
    ForceNetRelevant();
    // End:0x114
    if(RemoteRole != ROLE_None)
    {
        SetForcedInitialReplicatedProperty(boolproperty'bCollideActors', bCollideActors == default.bCollideActors);
        SetForcedInitialReplicatedProperty(boolproperty'bBlockActors', bBlockActors == default.bBlockActors);
        SetForcedInitialReplicatedProperty(boolproperty'bHidden', bHidden == default.bHidden);
        SetForcedInitialReplicatedProperty(byteproperty'Physics', Physics == default.Physics);
    }
    NetUpdateFrequency = 0.10;
    bForceNetUpdate = true;
    //return;    
}

// Export UActor::execPrestreamTextures(FFrame&, void* const)
native function PrestreamTextures(float Seconds, bool bEnableStreaming, optional int CinematicTextureGroups)
{
    CinematicTextureGroups = 0;                    
}

simulated function OnModifyHealth(SeqAct_ModifyHealth Action)
{
    local Controller InstigatorController;
    local Pawn InstigatorPawn;

    InstigatorController = Controller(Action.Instigator);
    // End:0xA8
    if(InstigatorController == none)
    {
        InstigatorPawn = Pawn(Action.Instigator);
        // End:0xA8
        if(InstigatorPawn != none)
        {
            InstigatorController = InstigatorPawn.Controller;
        }
    }
    // End:0x11E
    if(Action.bHeal)
    {
        HealDamage(int(Action.Amount), InstigatorController, Action.DamageType);
    }
    // End:0x1A7
    else
    {
        TakeDamage(int(Action.Amount), InstigatorController, Location, vector(Rotation) * -Action.Momentum, Action.DamageType);
    }
    //return;    
}

simulated function OnTeleport(SeqAct_Teleport Action)
{
    local array<Object> objVars;
    local int Idx;
    local Actor destActor, tempActor, A;
    local Controller C;
    local bool bOccupiedDest, bColliding;
    local float ColRadius, ColHeight;
    local Vector Extent;

    GetBoundingCylinder(ColRadius, ColHeight);
    Extent.X = ColRadius;
    Extent.Y = ColRadius;
    Extent.Z = ColHeight;
    bOccupiedDest = false;
    Action.GetObjectVars(objVars, "Destination");
    Idx = 0;
    J0xDA:
    // End:0x2CA [Loop If]
    if(Idx < objVars.Length)
    {
        tempActor = Actor(objVars[Idx]);
        // End:0x12A
        if(tempActor == none)
        {
        }
        // End:0x2BC
        else
        {
            C = Controller(tempActor);
            // End:0x1A3
            if((C != none) && C.Pawn != none)
            {
                tempActor = C.Pawn;
            }
            // End:0x260
            if(Action.bCheckOverlap)
            {
                bColliding = false;
                // End:0x24A
                foreach VisibleCollidingActors(class'Actor', A, ColRadius * 2.0, tempActor.Location, false, Extent, true)
                {
                    // End:0x249
                    if(IsBlockedBy(A))
                    {
                        bColliding = true;
                        // End:0x24A
                        break;
                    }                    
                }                
                bOccupiedDest = bColliding;
            }
            destActor = tempActor;
            // End:0x2BC
            if((!Action.bCheckOverlap || !bOccupiedDest) && destActor != none)
            {
                // [Explicit Break]
                goto J0x2CA;
            }
        }
        ++ Idx;
        J0x2CA:
        // [Loop Continue]
        goto J0xDA;
    }
    // End:0x419
    if((destActor != none) && Action.ShouldTeleport(self, destActor.Location, Action.TeleportDistance, Action.TeleportVolumes))
    {
        // End:0x3F0
        if(SetLocation(destActor.Location))
        {
            PlayTeleportEffect(false, true);
            // End:0x3CB
            if(Action.bUpdateRotation)
            {
                SetRotation(destActor.Rotation);
            }
            ForceNetRelevant();
            bUpdateSimulatedPosition = true;
            bNetDirty = true;
        }
        // End:0x416
        else
        {
            WarnInternal("Unable to teleport to" @ string(destActor));
        }
    }
    // End:0x44E
    else
    {
        // End:0x44E
        if(destActor != none)
        {
            WarnInternal("Unable to teleport to" @ string(destActor));
        }
    }
    //return;    
}

simulated function OnSetVelocity(SeqAct_SetVelocity Action)
{
    local Vector V;
    local float Mag;

    Mag = Action.VelocityMag;
    // End:0x65
    if(Mag <= 0.0)
    {
        Mag = VSize(Action.VelocityDir);
    }
    V = Normal(Action.VelocityDir) * Mag;
    // End:0xDB
    if(Action.bVelocityRelativeToActorRotation)
    {
        V = V >> Rotation;
    }
    Velocity = V;
    // End:0x13C
    if((Physics == 10) && CollisionComponent != none)
    {
        CollisionComponent.SetRBLinearVelocity(Velocity);
    }
    //return;    
}

simulated function OnSetBlockRigidBody(SeqAct_SetBlockRigidBody Action)
{
    // End:0xC0
    if(CollisionComponent != none)
    {
        // End:0x69
        if(Action.InputLinks[0].bHasImpulse)
        {
            CollisionComponent.SetBlockRigidBody(true);
        }
        // End:0xC0
        else
        {
            // End:0xC0
            if(Action.InputLinks[1].bHasImpulse)
            {
                CollisionComponent.SetBlockRigidBody(false);
            }
        }
    }
    //return;    
}

simulated function OnSetPhysics(SeqAct_SetPhysics Action)
{
    ForceNetRelevant();
    SetPhysics(Action.newPhysics);
    // End:0xA3
    if(RemoteRole != ROLE_None)
    {
        // End:0x78
        if(Physics != 0)
        {
            bUpdateSimulatedPosition = true;
            // End:0x78
            if(bOnlyDirtyReplication)
            {
                bNetDirty = true;
            }
        }
        SetForcedInitialReplicatedProperty(byteproperty'Physics', Physics == default.Physics);
    }
    //return;    
}

function OnChangeCollision(SeqAct_ChangeCollision Action)
{
    // End:0xA5
    if(Action.ObjInstanceVersion < Action.GetObjClassVersion())
    {
        SetCollision(Action.bCollideActors, Action.bBlockActors, Action.bIgnoreEncroachers);
    }
    // End:0xCD
    else
    {
        SetCollisionType(Action.CollisionType);
    }
    ForceNetRelevant();
    // End:0x13D
    if(RemoteRole != ROLE_None)
    {
        SetForcedInitialReplicatedProperty(boolproperty'bCollideActors', bCollideActors == default.bCollideActors);
        SetForcedInitialReplicatedProperty(boolproperty'bBlockActors', bBlockActors == default.bBlockActors);
    }
    //return;    
}

simulated function OnToggleHidden(SeqAct_ToggleHidden Action)
{
    local int AttachIdx, IgnoreIdx;
    local Actor A;

    // End:0x14A
    if(Action.bToggleBasedActors)
    {
        AttachIdx = 0;
        J0x2D:
        // End:0x14A [Loop If]
        if(AttachIdx < Attached.Length)
        {
            A = Attached[AttachIdx];
            IgnoreIdx = 0;
            J0x6D:
            // End:0x102 [Loop If]
            if(IgnoreIdx < Action.IgnoreBasedClasses.Length)
            {
                // End:0xF4
                if(ClassIsChildOf(A.Class, Action.IgnoreBasedClasses[IgnoreIdx]))
                {
                    A = none;
                    // [Explicit Break]
                    goto J0x102;
                }
                ++ IgnoreIdx;
                J0x102:
                // [Loop Continue]
                goto J0x6D;
            }
            // End:0x114
            if(A == none)
            {
            }
            // End:0x13C
            else
            {
                A.OnToggleHidden(Action);
            }
            ++ AttachIdx;
            // [Loop Continue]
            goto J0x2D;
        }
    }
    // End:0x18F
    if(Action.InputLinks[0].bHasImpulse)
    {
        SetHidden(true);
    }
    // End:0x1EA
    else
    {
        // End:0x1D4
        if(Action.InputLinks[1].bHasImpulse)
        {
            SetHidden(false);
        }
        // End:0x1EA
        else
        {
            SetHidden(!bHidden);
        }
    }
    ForceNetRelevant();
    // End:0x231
    if(RemoteRole != ROLE_None)
    {
        SetForcedInitialReplicatedProperty(boolproperty'bHidden', bHidden == default.bHidden);
    }
    //return;    
}

function OnAttachToActor(SeqAct_AttachToActor Action)
{
    local int Idx;
    local Actor Attachment;
    local Controller C;
    local array<Object> objVars;

    Action.GetObjectVars(objVars, "Attachment");
    Idx = 0;
    J0x3F:
    // End:0x233 [Loop If]
    if((Idx < objVars.Length) && Attachment == none)
    {
        Attachment = Actor(objVars[Idx]);
        C = Controller(Attachment);
        // End:0x107
        if((C != none) && C.Pawn != none)
        {
            Attachment = C.Pawn;
        }
        // End:0x225
        if(Attachment != none)
        {
            // End:0x177
            if(Action.bDetach)
            {
                Attachment.SetBase(none);
                Attachment.SetHardAttach(false);
            }
            // End:0x225
            else
            {
                C = Controller(self);
                // End:0x209
                if((C != none) && C.Pawn != none)
                {
                    C.Pawn.DoKismetAttachment(Attachment, Action);
                }
                // End:0x225
                else
                {
                    DoKismetAttachment(Attachment, Action);
                }
            }
        }
        ++ Idx;
        // [Loop Continue]
        goto J0x3F;
    }
    //return;    
}

function DoKismetAttachment(Actor Attachment, SeqAct_AttachToActor Action)
{
    local bool bOldCollideActors, bOldBlockActors;
    local Vector X, Y, Z;

    Attachment.SetBase(none);
    Attachment.SetHardAttach(Action.bHardAttach);
    // End:0x2C3
    if(Action.bUseRelativeOffset || Action.bUseRelativeRotation)
    {
        bOldCollideActors = Attachment.bCollideActors;
        bOldBlockActors = Attachment.bBlockActors;
        Attachment.SetCollision(false, false);
        // End:0x173
        if(Action.bUseRelativeRotation)
        {
            Attachment.SetRotation(Rotation + Action.RelativeRotation);
        }
        // End:0x296
        if(Action.bUseRelativeOffset)
        {
            GetAxes(Rotation, X, Y, Z);
            Attachment.SetLocation(((Location + (Action.RelativeOffset.X * X)) + (Action.RelativeOffset.Y * Y)) + (Action.RelativeOffset.Z * Z));
        }
        Attachment.SetCollision(bOldCollideActors, bOldBlockActors);
    }
    Attachment.SetBase(self);
    Attachment.ForceNetRelevant();
    Attachment.bNetDirty = true;
    // End:0x45C
    if((Attachment.RemoteRole != ROLE_None) && Attachment.bStatic || Attachment.bNoDelete)
    {
        Attachment.SetForcedInitialReplicatedProperty(structproperty'RelativeLocation', Attachment.RelativeLocation == Attachment.default.RelativeLocation);
        Attachment.SetForcedInitialReplicatedProperty(structproperty'RelativeRotation', Attachment.RelativeRotation == Attachment.default.RelativeRotation);
    }
    //return;    
}

event OnAnimEnd(AnimNodeSequence SeqNode, float PlayedTime, float ExcessTime)
{
    //return;    
}

event OnAnimPlay(AnimNodeSequence SeqNode)
{
    //return;    
}

event BeginAnimControl(InterpGroup InInterpGroup)
{
    //return;    
}

event SetAnimPosition(name SlotName, int ChannelIndex, name InAnimSeqName, float InPosition, bool bFireNotifies, bool bLooping, bool bEnableRootMotion)
{
    //return;    
}

event FinishAnimControl(InterpGroup InInterpGroup)
{
    //return;    
}

event bool PlayActorFaceFXAnim(FaceFXAnimSet AnimSet, string GroupName, string SeqName, SoundCue SoundCueToPlay)
{
    //return ReturnValue;    
}

event StopActorFaceFXAnim()
{
    //return;    
}

event SetMorphWeight(name MorphNodeName, float MorphWeight)
{
    //return;    
}

event SetSkelControlScale(name SkelControlName, float Scale)
{
    //return;    
}

event TickSkelControl(float DeltaTime, SkeletalMeshComponent SkelComp, SkelControlBase SkelCtrl)
{
    //return;    
}

simulated function bool IsActorPlayingFaceFXAnim()
{
    return false;
    //return ReturnValue;    
}

simulated function bool CanActorPlayFaceFXAnim()
{
    return true;
    //return ReturnValue;    
}

event FaceFXAsset GetActorFaceFXAsset()
{
    //return ReturnValue;    
}

function bool IsStationary()
{
    return true;
    //return ReturnValue;    
}

simulated event GetActorEyesViewPoint(out Vector out_Location, out Rotator out_Rotation)
{
    out_Location = Location;
    out_Rotation = Rotation;
    //return;    
}

// Export UActor::execIsPlayerOwned(FFrame&, void* const)
native simulated function bool IsPlayerOwned();

function PawnBaseDied()
{
    //return;    
}

// Export UActor::execGetTeamNum(FFrame&, void* const)
native simulated function byte GetTeamNum();

simulated event byte ScriptGetTeamNum()
{
    return 255;
    //return ReturnValue;    
}

simulated function NotifyLocalPlayerTeamReceived()
{
    //return;    
}

simulated function FindGoodEndView(PlayerController PC, out Rotator GoodRotation)
{
    GoodRotation = PC.Rotation;
    //return;    
}

// Export UActor::execGetTargetLocation(FFrame&, void* const)
native simulated function Vector GetTargetLocation(optional Actor RequestedBy, optional bool bRequestAlternateLoc);

event SpawnedByKismet()
{
    //return;    
}

simulated event InterpolationStarted(SeqAct_Interp InterpAction, InterpGroupInst GroupInst)
{
    //return;    
}

simulated event InterpolationFinished(SeqAct_Interp InterpAction)
{
    //return;    
}

simulated event InterpolationChanged(SeqAct_Interp InterpAction)
{
    //return;    
}

event RigidBodyCollision(PrimitiveComponent HitComponent, PrimitiveComponent OtherComponent, const out CollisionImpactData RigidCollisionData, int ContactIndex)
{
    //return;    
}

event OnRanOver(SVehicle Vehicle, PrimitiveComponent RunOverComponent, int WheelIndex)
{
    //return;    
}

// Export UActor::execSetHUDLocation(FFrame&, void* const)
native simulated function SetHUDLocation(Vector NewHUDLocation);

// Export UActor::execNativePostRenderFor(FFrame&, void* const)
native simulated function NativePostRenderFor(PlayerController PC, Canvas Canvas, Vector CameraPosition, Vector CameraDir);

simulated event PostRenderFor(PlayerController PC, Canvas Canvas, Vector CameraPosition, Vector CameraDir)
{
    //return;    
}

simulated event RootMotionModeChanged(SkeletalMeshComponent SkelComp)
{
    //return;    
}

simulated event RootMotionProcessed(SkeletalMeshComponent SkelComp)
{
    //return;    
}

simulated event RootMotionExtracted(SkeletalMeshComponent SkelComp, out BoneAtom ExtractedRootMotionDelta)
{
    //return;    
}

event PostInitAnimTree(SkeletalMeshComponent SkelComp)
{
    //return;    
}

// Export UActor::execGetPackageGuid(FFrame&, void* const)
native static final function Guid GetPackageGuid(name PackageName);

simulated event OnRigidBodySpringOverextension(RB_BodyInstance BodyInstance)
{
    //return;    
}

// Export UActor::execIsInPersistentLevel(FFrame&, void* const)
native final function bool IsInPersistentLevel(optional bool bIncludeLevelStreamingPersistent);

simulated function GetAimFrictionExtent(out float Width, out float Height, out Vector Center)
{
    // End:0x2C
    if(bCanBeFrictionedTo)
    {
        GetBoundingCylinder(Width, Height);
    }
    // End:0x4A
    else
    {
        Width = 0.0;
        Height = 0.0;
    }
    Center = Location;
    //return;    
}

simulated function GetAimAdhesionExtent(out float Width, out float Height, out Vector Center)
{
    // End:0x2C
    if(bCanBeAdheredTo)
    {
        GetBoundingCylinder(Width, Height);
    }
    // End:0x4A
    else
    {
        Width = 0.0;
        Height = 0.0;
    }
    Center = Location;
    //return;    
}

event bool PlayParticleEffect(const AnimNotify_PlayParticleEffect AnimNotifyData)
{
    // End:0x60
    if(WorldInfo.NetMode == NM_DedicatedServer)
    {
        LogInternal("(Actor): PlayParticleEffect on dedicated server!");
        return true;
    }
    return false;
    //return ReturnValue;    
}

event bool CreateForceField(const AnimNotify_ForceField AnimNotifyData)
{
    return false;
    //return ReturnValue;    
}

event TrailsNotify(const AnimNotify_Trails AnimNotifyData)
{
    //return;    
}

event TrailsNotifyTick(const AnimNotify_Trails AnimNotifyData)
{
    //return;    
}

event TrailsNotifyEnd(const AnimNotify_Trails AnimNotifyData)
{
    //return;    
}

// Export UActor::execGetAnimTrailParticleSystem(FFrame&, void* const)
native function ParticleSystem GetAnimTrailParticleSystem(const AnimNotify_Trails AnimNotifyData);

// Export UActor::execSupportsKismetModification(FFrame&, void* const)
native final function bool SupportsKismetModification(SequenceOp AskingOp, out string Reason);

simulated event AnimTreeUpdated(SkeletalMeshComponent SkelMesh)
{
    //return;    
}

simulated event PostDemoRewind()
{
    //return;    
}

simulated event ReplicationEnded()
{
    //return;    
}

// Export UActor::execGetAvoidanceVector(FFrame&, void* const)
native final function Vector GetAvoidanceVector(const out array<Actor> Obstacles, Vector GoalLocation, float CollisionRadius, float MaxSpeed, optional int NumSamples, optional float VelocityStepRate, optional float MaxTimeTilOverlap)
{
    NumSamples = 8;
    VelocityStepRate = 0.10;
    MaxTimeTilOverlap = 1.0;                                    
}

// Export UActor::execWillOverlap(FFrame&, void* const)
native final function bool WillOverlap(Vector PosA, Vector VelA, Vector PosB, Vector VelB, float StepSize, float Radius, out float Time);

// Export UActor::execShouldBeHiddenBySHOW_NavigationNodes(FFrame&, void* const)
native function bool ShouldBeHiddenBySHOW_NavigationNodes();

function bool IsMobileTouchEnabled()
{
    return bEnableMobileTouch && bCollideActors;
    //return ReturnValue;    
}

event bool OnMobileTouch(PlayerController InPC, Vector2D TouchLocation)
{
    TriggerEventClass(class'SeqEvent_MobileTouch', InPC, 0);
    return true;
    //return ReturnValue;    
}

// Export UActor::execGetActorMetrics(FFrame&, void* const)
native simulated function int GetActorMetrics(Actor.EActorMetricsType MetricsType);

// Export UActor::execGetActorSpriteComponent(FFrame&, void* const)
native function SpriteComponent GetActorSpriteComponent();

// Export UActor::execSetS1GameObject(FFrame&, void* const)
native final function SetS1GameObject();

defaultproperties
{
    DrawScale=1.0
    DrawScale3D=(X=1.0,Y=1.0,Z=1.0)
    EditorIconColor=(R=255,G=255,B=255,A=255)
    CustomTimeDilation=1.0
    Role=ENetRole.ROLE_Authority
    ReplicatedCollisionType=ECollisionType.None
    bPushedByEncroachers=true
    bRouteBeginPlayEvenIfStatic=true
    bCanStepUpOn=true
    bReplicateMovement=true
    bAllowFluidSurfaceInteraction=true
    bSkipAttachedMoves=true
    bMovable=true
    bJustTeleported=true
    bEditable=true
    NetUpdateFrequency=100.0
    NetPriority=1.0
    MessageClass=class'LocalMessage'
    SupportedEvents(0)=class'SeqEvent_Touch'
    SupportedEvents(1)=class'SeqEvent_Destroyed'
    SupportedEvents(2)=class'SeqEvent_TakeDamage'
    SupportedEvents(3)=class'SeqEvent_HitWall'
    SupportedEvents(4)=class'SeqEvent_AnimNotify'
    SupportedEvents(5)=class'SeqEvent_MobileTouch'
}