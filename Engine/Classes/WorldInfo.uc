/*******************************************************************************
 * WorldInfo generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2015 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class WorldInfo extends ZoneInfo
    native(GameEngine)
    nativereplication
    config(Game)
    notplaceable
    hidecategories(Navigation,Movement,Collision,Actor,Advanced,Display,Events,Object,Attachment);

const MAX_BOOKMARK_NUMBER = 10;
const MAX_INSTANCES_PER_CLASS = 5;

enum ENetMode
{
    NM_Standalone,
    NM_DedicatedServer,
    NM_ListenServer,
    NM_Client,
    NM_MAX
};

enum EConsoleType
{
    CONSOLE_Any,
    CONSOLE_Xbox360,
    CONSOLE_PS3,
    CONSOLE_Mobile,
    CONSOLE_IPhone,
    CONSOLE_Android,
    CONSOLE_Kindle,
    CONSOLE_Android_Google,
    CONSOLE_Android_Amazon,
    CONSOLE_WiiU,
    CONSOLE_Flash,
    CONSOLE_Orbis,
    CONSOLE_Durango,
    CONSOLE_MAX
};

enum EVisibilityAggressiveness
{
    VIS_LeastAggressive,
    VIS_ModeratelyAggressive,
    VIS_MostAggressive,
    VIS_Max
};

enum EPreferredLightmapType
{
    EPLT_Default,
    EPLT_Directional,
    EPLT_Simple,
    EPLT_MAX
};

enum EHostMigrationProgress
{
    HostMigration_None,
    HostMigration_FindingNewHost,
    HostMigration_MigratingAsHost,
    HostMigration_MigratingAsClient,
    HostMigration_ClientTravel,
    HostMigration_HostReadyToTravel,
    HostMigration_Failed,
    HostMigration_MAX
};

struct native NetViewer
{
    var PlayerController InViewer;
    var Actor Viewer;
    var Vector ViewLocation;
    var Vector ViewDir;

    structdefaultproperties
    {
        InViewer=none
        Viewer=none
        ViewLocation=(X=0.0,Y=0.0,Z=0.0)
        ViewDir=(X=0.0,Y=0.0,Z=0.0)
    }
};

struct native CompartmentRunList
{
    /** The rigid body compartment will run on this frame */
    var() bool RigidBody;
    /** The fluid compartment will run on this frame */
    var() bool Fluid;
    /** The cloth compartment will run on this frame */
    var() bool Cloth;
    /** The soft body compartment will run on this frame */
    var() bool SoftBody;

    structdefaultproperties
    {
        RigidBody=true
        Fluid=true
        Cloth=true
        SoftBody=true
    }
};

struct native PhysXSimulationProperties
{
    /** Whether or not to put the scene (or compartment) in PhysX hardware, if available. */
    var() bool bUseHardware;
    /**  
     *If true, substep sizes are fixed equal to TimeStep.
     *               If false, substep sizes are varied to fit an integer number of times into the frame time.
     */
    var() bool bFixedTimeStep;
    /** The fixed or maximum substep size, depending on the value of bFixedTimeStep. */
    var() float TimeStep;
    /** The maximum number of substeps allowed per frame. */
    var() int MaxSubSteps;

    structdefaultproperties
    {
        bUseHardware=false
        bFixedTimeStep=false
        TimeStep=0.020
        MaxSubSteps=5
    }
};

struct native PhysXSceneProperties
{
    /** Timing settings for the PhysX primary scene */
    var() editinline PhysXSimulationProperties PrimaryScene;
    /** Timing settings for the PhysX rigid body compartment */
    var() editinline PhysXSimulationProperties CompartmentRigidBody;
    /** Timing settings for the PhysX fluid compartment */
    var() editinline PhysXSimulationProperties CompartmentFluid;
    /** Timing settings for the PhysX cloth compartment */
    var() editinline PhysXSimulationProperties CompartmentCloth;
    /** Timing settings for the PhysX soft body compartment */
    var() editinline PhysXSimulationProperties CompartmentSoftBody;

    structdefaultproperties
    {
        PrimaryScene=(bUseHardware=false,bFixedTimeStep=false,TimeStep=0.020,MaxSubSteps=5)
        CompartmentRigidBody=(bUseHardware=false,bFixedTimeStep=false,TimeStep=0.020,MaxSubSteps=2)
        CompartmentFluid=(bUseHardware=true,bFixedTimeStep=false,TimeStep=0.020,MaxSubSteps=1)
        CompartmentCloth=(bUseHardware=true,bFixedTimeStep=true,TimeStep=0.020,MaxSubSteps=2)
        CompartmentSoftBody=(bUseHardware=true,bFixedTimeStep=true,TimeStep=0.020,MaxSubSteps=2)
    }
};

struct native ApexModuleDestructibleSettings
{
    /**  
     *The maximum number of active PhysX actors which represent dynamic groups of chunks (islands).  If a 
     *               fracturing event would cause more islands to be created, then oldest islands are released and the chunks
     *               they represent destroyed. If negative the INI setting will be used instead.
     */
    var() int MaxChunkIslandCount;
    /**  
     *The maximum number of PhysX shapes which represent destructible chunks.  
     *               If a fracturing event would cause more shapes to be created, then oldest islands are released 
     *               and the chunks they represent destroyed.
     */
    var() int MaxShapeCount;
    var int MaxRrbActorCount;
    /**  
     *Every destructible asset defines a min and max lifetime, and maximum separation distance for its chunks.
     *               Chunk islands are destroyed after this time or separation from their origins. This parameter sets the
     *               lifetimes and max separations within their min-max ranges. The valid range is [0,1].
     */
    var() float MaxChunkSeparationLOD<ClampMin=0.0|ClampMax=1.0>;
    /** If set, override the INI setting with Max Chunk Separation LOD in the WorldInfo properties. */
    var() bool bOverrideMaxChunkSeparationLOD;

    structdefaultproperties
    {
        MaxChunkIslandCount=-1
        MaxShapeCount=-1
        MaxRrbActorCount=-1
        MaxChunkSeparationLOD=1.0
        bOverrideMaxChunkSeparationLOD=false
    }
};

struct native PhysXEmitterVerticalProperties
{
    /** Parameters for emitter vertical */
    var() bool bDisableLod;
    /** Min value for particle LOD range. */
    var() int ParticlesLodMin;
    /** Max value for particle LOD range. */
    var() int ParticlesLodMax;
    /** Limit for packets per PhysXParticleSystem. Caped to 900. */
    var() int PacketsPerPhysXParticleSystemMax;
    /** Selects either cylindrical or spherical packet range culling. */
    var() bool bApplyCylindricalPacketCulling;
    /**  
     *Parameter for scaling spawn lod impact. 1.0: As much as possible lod through
     *               emitter spawn rate/lifetime control. 0.0: Lod constraint handled only through
     *               fifo control.
     */
    var() float SpawnLodVsFifoBias;

    structdefaultproperties
    {
        bDisableLod=true
        ParticlesLodMin=0
        ParticlesLodMax=15000
        PacketsPerPhysXParticleSystemMax=500
        bApplyCylindricalPacketCulling=true
        SpawnLodVsFifoBias=1.0
    }
};

struct native PhysXVerticalProperties
{
    /** Parameters for Emitter Vertical */
    var() editinline PhysXEmitterVerticalProperties Emitters;

    structdefaultproperties
    {
        Emitters=(bDisableLod=true,ParticlesLodMin=0,ParticlesLodMax=15000,PacketsPerPhysXParticleSystemMax=500,bApplyCylindricalPacketCulling=true,SpawnLodVsFifoBias=1.0)
    }
};

struct native WorldFractureSettings
{
    var float ChanceOfPhysicsChunkOverride;
    var bool bEnableChanceOfPhysicsChunkOverride;
    var bool bLimitExplosionChunkSize;
    var float MaxExplosionChunkSize;
    var bool bLimitDamageChunkSize;
    var float MaxDamageChunkSize;
    var int MaxNumFacturedChunksToSpawnInAFrame;
    var float FractureExplosionVelScale;

    structdefaultproperties
    {
        ChanceOfPhysicsChunkOverride=0.0
        bEnableChanceOfPhysicsChunkOverride=false
        bLimitExplosionChunkSize=false
        MaxExplosionChunkSize=0.0
        bLimitDamageChunkSize=false
        MaxDamageChunkSize=0.0
        MaxNumFacturedChunksToSpawnInAFrame=0
        FractureExplosionVelScale=0.0
    }
};

struct native transient ScreenMessageString
{
    var init transient QWord Key;
    var init transient string ScreenMessage;
    var init transient Color DisplayColor;
    var init transient float TimeToDisplay;
    var init transient float CurrentTimeDisplayed;

    structdefaultproperties
    {
        Key=none
        ScreenMessage=""
        DisplayColor=(R=0,G=0,B=0,A=0)
        TimeToDisplay=0.0
        CurrentTimeDisplayed=0.0
    }
};

struct native LightmassWorldInfoSettings
{
    /**  
     *Scale of the level relative to Gears of War 2 levels. 
     *        All scale-dependent Lightmass setting defaults have been tweaked to work well in Gears 2 levels, 
     *        Any levels with a different scale should use this scale to compensate.
     */
    var(General) float StaticLightingLevelScale;
    /**  
     *Number of times light is allowed to bounce off of surfaces, starting from the light source. 
     *        0 is direct lighting only, 1 is one bounce, etc. 
     *        Bounce 1 takes the most time to calculate and contributes the most to visual quality, followed by bounce 2.  
     *        Successive bounces are nearly free, but have a much lower impact.
     */
    var(General) int NumIndirectLightingBounces;
    /**  
     *Color that rays which miss the scene will pick up.  
     *        This is effectively a light surrounding the entire level that is shadowed, but doesn't emit indirect lighting.
     */
    var(General) Color EnvironmentColor;
    /** Scales EnvironmentColor to allow independent color and brightness controls. */
    var(General) float EnvironmentIntensity;
    /**  
     *In advanced mode the color that rays which miss the scen will pick up depends on 'sun'.
     *         The closer ray's direction is to the direction of sun the more color of sun is blended/added into picked color.
     */
    var(AdvancedEnvironmentColor) bool bEnableAdvancedEnvironmentColor;
    /** Color of the sun */
    var(AdvancedEnvironmentColor) Color EnvironmentSunColor;
    /** Scales EnvironmentSunColor to allow independent color and brightness controls. */
    var(AdvancedEnvironmentColor) float EnvironmentSunIntensity;
    /** In degrees. Range of sun color. */
    var(AdvancedEnvironmentColor) float EnvironmentLightTerminatorAngle;
    /** If this value is zeroed, the direction of dominant directional light on current scene will be used */
    var(AdvancedEnvironmentColor) Vector EnvironmentLightDirection;
    /** Scales the emissive contribution of all materials in the scene. */
    var(General) float EmissiveBoost;
    /** Scales the diffuse contribution of all materials in the scene. */
    var(General) float DiffuseBoost;
    var float SpecularBoost;
    /**  
     *Lerp factor that controls the influence of normal maps with directional lightmaps on indirect lighting.
     *        A value of 0 gives a physically correct distribution of light, which may result in little normal influence in areas only lit by indirect lighting, but less lightmap compression artifacts.
     *        A value of .8 results in 80% of the lighting being redistributed in the dominant incident lighting direction, which effectively increases the per-pixel normal's influence,
     *        But causes more severe lightmap compression artifacts.
     */
    var(General) float IndirectNormalInfluenceBoost;
    /** If TRUE, AmbientOcclusion will be enabled. */
    var(Occlusion) bool bUseAmbientOcclusion;
    /** If TRUE, Lightmass will generate static shadowing information for image reflections. */
    var(Occlusion) bool bEnableImageReflectionShadowing;
    /** How much of the AO to apply to direct lighting. */
    var(Occlusion) float DirectIlluminationOcclusionFraction;
    /** How much of the AO to apply to indirect lighting. */
    var(Occlusion) float IndirectIlluminationOcclusionFraction;
    /** Higher exponents increase contrast. */
    var(Occlusion) float OcclusionExponent;
    /** Fraction of samples taken that must be occluded in order to reach full occlusion. */
    var(Occlusion) float FullyOccludedSamplesFraction;
    /** Maximum distance for an object to cause occlusion on another object. */
    var(Occlusion) float MaxOcclusionDistance;
    /** If TRUE, override normal direct and indirect lighting with just the exported diffuse term. */
    var(Debug) bool bVisualizeMaterialDiffuse;
    /** If TRUE, override normal direct and indirect lighting with just the AO term. */
    var(Debug) bool bVisualizeAmbientOcclusion;
    /** If TRUE, compress shadowmap with DXT1. */
    var(General) bool bCompressShadowmap;

    structdefaultproperties
    {
        StaticLightingLevelScale=1.0
        NumIndirectLightingBounces=3
        EnvironmentColor=(R=0,G=0,B=0,A=0)
        EnvironmentIntensity=1.0
        bEnableAdvancedEnvironmentColor=false
        EnvironmentSunColor=(R=0,G=0,B=0,A=0)
        EnvironmentSunIntensity=1.0
        EnvironmentLightTerminatorAngle=90.0
        EnvironmentLightDirection=(X=0.0,Y=0.0,Z=0.0)
        EmissiveBoost=1.0
        DiffuseBoost=5.0
        SpecularBoost=1.0
        IndirectNormalInfluenceBoost=0.30
        bUseAmbientOcclusion=false
        bEnableImageReflectionShadowing=false
        DirectIlluminationOcclusionFraction=0.50
        IndirectIlluminationOcclusionFraction=1.0
        OcclusionExponent=1.0
        FullyOccludedSamplesFraction=1.0
        MaxOcclusionDistance=200.0
        bVisualizeMaterialDiffuse=false
        bVisualizeAmbientOcclusion=false
        bCompressShadowmap=false
    }
};

struct native NavMeshPathConstraintCacheDatum
{
    var int ListIdx;
    var NavMeshPathConstraint List[5];

    structdefaultproperties
    {
        ListIdx=0
        List[0]=none
        List[1]=none
        List[2]=none
        List[3]=none
        List[4]=none
    }
};

struct native NavMeshPathGoalEvaluatorCacheDatum
{
    var int ListIdx;
    var NavMeshPathGoalEvaluator List[5];

    structdefaultproperties
    {
        ListIdx=0
        List[0]=none
        List[1]=none
        List[2]=none
        List[3]=none
        List[4]=none
    }
};

struct native HostMigrationState
{
    var WorldInfo.EHostMigrationProgress HostMigrationProgress;
    var float HostMigrationElapsedTime;
    var float HostMigrationTravelCountdown;
    var string HostMigrationTravelURL;
    var bool bHostMigrationEnabled;

    structdefaultproperties
    {
        HostMigrationProgress=EHostMigrationProgress.HostMigration_None
        HostMigrationElapsedTime=0.0
        HostMigrationTravelCountdown=0.0
        HostMigrationTravelURL=""
        bHostMigrationEnabled=false
    }
};

/** Default post process settings used by post processing volumes. */
var(Rendering) config PostProcessSettings DefaultPostProcessSettings;
/** The post process chain for the entire world */
var(Rendering) PostProcessChain WorldPostProcessChain;
/** Whether or not post process effects should persist when this level is unloaded */
var(Rendering) config bool bPersistPostProcessToNextLevel;
/** Mobile only: Enables distance-based fog globally for this level */
var(Mobile) bool bFogEnabled;
/** Mobile only: Enables bump offset mapping for this level for mobile materials that use that */
var(Mobile) bool bBumpOffsetEnabled;
/** Mobile: True to enable gamma correction for all shaders when rendering this level.  Enabling this will yield lighting that more closely resembles other platforms, but may reduce rendering performance slightly. */
var(Mobile) bool bUseGammaCorrection;
var bool bMapNeedsLightingFullyRebuilt;
var bool bMapHasMultipleDominantLightsAffectingOnePrimitive;
var bool bMapHasPathingErrors;
var bool bRequestedBlockOnAsyncLoading;
var bool bBegunPlay;
var bool bPlayersOnly;
var bool bPlayersOnlyPending;
var bool bSuspendAI;
var transient bool bDropDetail;
var transient bool bAggressiveLOD;
var bool bStartup;
var bool bPathsRebuilt;
var bool bHasPathNodes;
var const transient bool bIsMenuLevel;
var editoronly const transient bool bDebugPauseExecution;
var editoronly const transient bool bDebugStepExecution;
var transient bool bUseConsoleInput;
/**  
 *Causes the BSP build to generate as few sections as possible.  
 * This is useful when you need to reduce draw calls but can reduce texture streaming efficiency and effective lightmap resolution.
 * Note - changes require a rebuild to propagate.  Also, be sure to select all surfaces and make sure they all have the same flags to minimize section count.
 */
var(Rendering) bool bMinimizeBSPSections;
/** if true, do not grant player with default inventory (presumably, the LD's will be setting it manually) */
var() bool bNoDefaultInventoryForPlayer;
/** If true, don't add "no paths from" warnings to map error list in editor.  Useful for maps that don't need AI support, but still have a few NavigationPoint actors in them. */
var() bool bNoPathWarnings;
/** Flag for controlling whether Mobile warnings are shown in map checks */
var() config bool bNoMobileMapWarnings;
var bool bHighPriorityLoading;
var bool bHighPriorityLoadingLocal;
/**  
 *Overriding is useful for doing perf testing / load testing / being able to overcome memory issues in other tools until they are fixed
 * withOUT compromising the RuleSet creation process and the application of the rulesets in the level
 */
var(ProcBuildings) bool bUseProcBuildingRulesetOverride;
var const transient bool bInteractiveMode;
/** Double buffered physics compartments enabled */
var(PhysicsAdvanced) bool bSupportDoubleBufferedPhysics;
/** If TRUE, physics simulation will ignore time elapsed between frames, and use (0.033 TimeDilation) */
var(Physics) bool bPhysicsIgnoreDeltaTime;
/** If TRUE, uses ChanceOfPhysicsChunkOverride instead of that set in the FracturedStaticMesh. */
var(Fracture) private config bool bEnableChanceOfPhysicsChunkOverride;
/** If TRUE, limit the max dimension of the bounding box of a fracture chunk due to explosion to MaxExplosionChunkSize */
var(Fracture) private config bool bLimitExplosionChunkSize;
/** If TRUE, limit the max dimension of the bounding box of a fracture chunk due to weapon damage to bLimitDamageChunkSize */
var(Fracture) private config bool bLimitDamageChunkSize;
/**  
 *Whether to place visibility cells inside Precomputed Visibility Volumes and along camera tracks in this level. 
 * Precomputing visibility reduces rendering thread time at the cost of some runtime memory and somewhat increased lighting build times.
 */
var(PrecomputedVisibility) bool bPrecomputeVisibility;
/**  
 *Whether to place visibility cells on shadow casting surfaces only, or everywhere inside Precomputed Visibility Volumes. 
 * Placing cells everywhere in the volumes is useful for games where the camera is not restrained to an area around the ground,
 * But generates a lot more cells than just placing on surfaces, so build times and memory usage will increase.
 */
var(PrecomputedVisibility) bool bPlaceCellsOnSurfaces;
/** Whether to allow temporal AA. */
var(Rendering) globalconfig bool bAllowTemporalAA;
/** Whether this level should be using fully-featured global illumination. If not, it will use old-style direct lightmaps. */
var(Lightmass) editoronly bool bUseGlobalIllumination;
/**  
 *Whether to force lightmaps and other precomputed lighting to not be created even when the engine thinks they are needed.
 * This is useful for improving iteration in levels with fully dynamic lighting and shadowing.
 * Note that any lighting and shadowing interactions that are usually precomputed will be lost if this is enabled.
 */
var(Lightmass) bool bForceNoPrecomputedLighting;
var bool bHaveActiveCrowd;
var config bool bAllowHostMigration;
var bool bGameplayFramePause;
/** Squint mode kernel size (same as DOF). */
var(Rendering) config float SquintModeKernelSize;
var noimport const transient PostProcessVolume HighestPriorityPostProcessVolume;
/** Default reverb settings used by reverb volumes. */
var(Audio) config ReverbSettings DefaultReverbSettings;
/** Default interior settings used by reverb volumes. */
var(Audio) config InteriorSettings DefaultAmbientZoneSettings;
/** Mobile only: Sets the distance fog start distance.  Can be negative. */
var(Mobile) float FogStart;
/** Mobile only: Sets the distance fog end distance.  Must be larger than FogStart. */
var(Mobile) float FogEnd;
/** Mobile only: Sets the distance fog color */
var(Mobile) Color FogColor;
/** Mobile only: Sets the bump offset threshold for mobile materials that use that */
var(Mobile) float BumpEnd;
var noimport const transient ReverbVolume HighestPriorityReverbVolume;
var noimport const transient array<MassiveLODOverrideVolume> MassiveLODOverrideVolumes;
var noimport const transient array<PortalVolume> PortalVolumes;
var noimport const transient array<EnvironmentVolume> EnvironmentVolumes;
var noimport const transient array<S1UnloadS1LevelVolume> UnloadS1LevelVolumes;
/** Level collection. ULevels are referenced by FName (Package name) to avoid serialized references. Also contains offsets in world units */
var() const editconst editinline array<editconst editinline LevelStreaming> StreamingLevels;
var transient Double LastTimeUnbuiltLightingWasEncountered;
/** Level bookmarks */
var(Editor) editoronly BookMark BookMarks[10];
/** Kismet bookmarks */
var(Editor) editoronly KismetBookMark KismetBookMarks[10];
/** Clip pad entries */
var(Editor) editoronly editinline array<editoronly editinline ClipPadEntry> ClipPadEntries;
/** #if WITH_S1airsulg AeroSetA??? */
var(AeroSet) array<AeroSet> AppliedAeroSets;
var float TimeDilation;
var float DemoPlayTimeDilation;
var transient float TimeSeconds;
var transient float RealTimeSeconds;
var transient float AudioTimeSeconds;
var const transient float DeltaSeconds;
var transient float PauseDelay;
var transient float RealTimeToUnPause;
var PlayerReplicationInfo Pauser;
var editoronly deprecated string VisibleGroups;
var editoronly string VisibleLayers;
var Texture2D DefaultTexture;
var Texture2D WireframeTexture;
var Texture2D WhiteSquareTexture;
var Texture2D LargeVertex;
var Texture2D BSPVertex;
var array<string> DeferredExecs;
var transient GameReplicationInfo GRI;
var WorldInfo.ENetMode NetMode;
var Actor.ETravelType NextTravelType;
/**  
 *Determines how aggressive precomputed visibility should be.  
 * More aggressive settings cull more objects but also cause more visibility errors like popping.
 */
var(PrecomputedVisibility) WorldInfo.EVisibilityAggressiveness VisibilityAggressiveness;
var WorldInfo.EPreferredLightmapType PreferredLightmapType;
/** The lighting quality the level was last built with */
var(Lightmass) editconst EngineTypes.ELightingBuildQuality LevelLightingQuality;
var string ComputerName;
var string EngineVersion;
var string MinNetVersion;
var GameInfo Game;
/** vehicles stall if they reach this */
var(ZoneInfo) float StallZ;
var transient float WorldGravityZ;
var const globalconfig float DefaultGravityZ;
/** optional level specific gravity override set by level designer */
var(ZoneInfo) float GlobalGravityZ;
var globalconfig float RBPhysicsGravityScaling;
var private const transient NavigationPoint NavigationPointList;
var private const Controller ControllerList;
var const Pawn PawnList;
var const transient CoverLink CoverList;
var private const transient Pylon PylonList;
var float MoveRepSize;
var const array<NetViewer> ReplicationViewers;
var string NextURL;
var float NextSwitchCountdown;
/** Maximum size of textures for packed light and shadow maps */
var(Rendering) int PackedLightAndShadowMapTextureSize;
/** Default color scale for the level */
var(Rendering) Vector DefaultColorScale;
/** The default game type to use when starting this map in the game. If this value is NULL, the INI setting for default game type is used. */
var(GameType) class<GameInfo> DefaultGameType;
/**  
 *This is the list of GameTypes which this map can support.  This is used for SeekFree loading
 * code so the map has a reference to the game type it will be played with so it can cook
 * all of the specific assets
 */
var(GameType) array< class<GameInfo> > GameTypesSupportedOnThisMap;
/**  
 *This is the gametype that should be used when starting the map in PIE. 
 * Note: if this value is not NULL it will override the DefaultGameType value when running PIE
 */
var(GameType) editoronly class<GameInfo> GameTypeForPIE;
var const editconst array<editconst Object> ClientDestroyedActorContent;
var const transient array<name> PreparingLevelNames;
var const transient name CommittedPersistentLevelName;
var ObjectReferencer PersistentMapForcedObjects;
var export editinline transient AudioComponent MusicComp;
var transient MusicTrackStruct CurrentMusicTrack;
var repnotify transient MusicTrackStruct ReplicatedMusicTrack;
/** title of the map displayed in the UI */
var() const localized string Title;
/** Who created this map */
var() string Author;
/** game specific map information - access through GetMapInfo()/SetMapInfo() */
var() protected export editinline MapInfo MyMapInfo;
var globalconfig string EmitterPoolClassPath;
var transient EmitterPool MyEmitterPool;
var globalconfig string DecalManagerClassPath;
var transient DecalManager MyDecalManager;
var globalconfig string FractureManagerClassPath;
var transient FractureManager MyFractureManager;
var globalconfig string ParticleEventManagerClassPath;
var transient ParticleEventManager MyParticleEventManager;
var(ProcBuildings) ProcBuildingRuleset ProcBuildingRulesetOverride;
var const transient int SkelMeshCompTickTagCount;
/** The maximum frame time allowed for physics calculations */
var(PhysicsAdvanced) float MaxPhysicsDeltaTime;
var config int MaxPhysicsSubsteps;
/** Timing parameters for the scene, primary and compartments. */
var(PhysicsAdvanced) editinline PhysXSceneProperties PhysicsProperties;
/** Which compartments run on which frames (list is cyclic).  An empty list means all compartments run on all frames. */
var(PhysicsAdvanced) array<CompartmentRunList> CompartmentRunFrames;
/** Default skin width */
var(PhysicsAdvanced) float DefaultSkinWidth;
/** Global APEX resource budget override. If negative the INI setting will be used instead. */
var(PhysicsAdvanced) float ApexLODResourceBudget;
/** A higher value would increase the amount of resources allocated to Apex Destruction */
var(PhysicsAdvanced) float ApexDestructionLODResourceValue;
/** A higher value would increase the amount of resources allocated to Apex Clothing */
var(PhysicsAdvanced) float ApexClothingLODResourceValue;
var(PhysicsAdvanced) ApexModuleDestructibleSettings DestructibleSettings;
var PhysicsLODVerticalEmitter EmitterVertical;
/** Vertical parameters. */
var(PhysicsAdvanced) editinline PhysXVerticalProperties VerticalProperties;
var private native array<Pointer> WorldAttractors;
/** Allows global override of the ChanceOfPhysicsChunk setting. */
var(Fracture) private config float ChanceOfPhysicsChunkOverride;
/** Max dimension of the bounding box of a fracture chunk due to explosion. */
var(Fracture) private config float MaxExplosionChunkSize;
/** Max dimension of the bounding box of a fracture chunk due to weapon damage. */
var(Fracture) private config float MaxDamageChunkSize;
/** Scaling for chunk thrown out during explosion on a fractured mesh */
var(Fracture) private config float FractureExplosionVelScale;
/** Max number of Fractured Chunks to Spawn in a frame. */
var(Fracture) private int MaxNumFacturedChunksToSpawnInAFrame;
var transient int NumFacturedChunksSpawnedThisFrame;
var config float FracturedMeshWeaponDamage;
/**  
 *World space size of precomputed visibility cells in x and y.
 * Smaller sizes produce more effective occlusion culling at the cost of increased runtime memory usage and lighting build times.
 */
var(PrecomputedVisibility) int VisibilityCellSize;
/** Brightness applied to the indirect lighting of character light environments that are lit by any dominant light. */
var(LightEnvironment) float CharacterLitIndirectBrightness<UIMin=0.1|UIMax=1.0|ClampMin=0.0|ClampMax=5.0>;
/** Contrast factor applied to the indirect lighting of character light environments that are lit by any dominant light. */
var(LightEnvironment) float CharacterLitIndirectContrastFactor<UIMin=1.0|UIMax=2.0|ClampMin=0.5|ClampMax=5.0>;
/** Brightness applied to the indirect lighting of character light environments that are shadowed by all dominant lights. */
var(LightEnvironment) float CharacterShadowedIndirectBrightness<UIMin=0.1|UIMax=1.0|ClampMin=0.0|ClampMax=5.0>;
/** Contrast factor applied to the indirect lighting of character light environments that are shadowed by all dominant lights. */
var(LightEnvironment) float CharacterShadowedIndirectContrastFactor<UIMin=1.0|UIMax=2.0|ClampMin=0.5|ClampMax=5.0>;
/**  
 *Increases the contrast of light environment lighting on characters by scaling up the brightest directions and scaling down the rest by this factor. 
 * Note that this setting only affects light environments completely in shadow from all dominant lights.
 */
var(LightEnvironment) float CharacterLightingContrastFactor<UIMin=1.0|UIMax=2.0|ClampMin=0.5|ClampMax=5.0>;
/**  
 *Panoramic environment texture for image reflections. 
 * The texture should be laid out so that the horizon is along the bottom (v = 0) and straight up in world space is along the top (v = 1).
 * The u direction of the texture then corresponds to rotation around the Z world axis.
 */
var(Rendering) Texture2D ImageReflectionEnvironmentTexture<bShowOnlyWhenTrue=bShowD3D11Properties>;
/** Color to be multiplied against ImageReflectionEnvironmentTexture.  Alpha controls brightness. */
var(Rendering) LinearColor ImageReflectionEnvironmentColor<bShowOnlyWhenTrue=bShowD3D11Properties>;
/** Angle to rotate the environment texture around the world Z axis, in degrees. */
var(Rendering) float ImageReflectionEnvironmentRotation<bShowOnlyWhenTrue=bShowD3D11Properties>;
var native transient Map_Mirror ScreenMessages;
var native transient array<ScreenMessageString> PriorityScreenMessages;
var editoronly int MaxTrianglesPerLeaf<FixedIncrement=4|ClampMin=4|Multiple=4>;
var editoronly export editinline deprecated LightmassLevelSettings LMLevelSettings;
var editoronly native transient map<0, 0> LandscapeInfoMap;
var(Lightmass) LightmassWorldInfoSettings LightmassSettings<ScriptOrder=true>;
var native map<0, 0> NavMeshPathConstraintCache;
var native map<0, 0> NavMeshPathGoalEvaluatorCache;
var CrowdPopulationManagerBase PopulationManager;
var const transient HostMigrationState PeerHostMigration;
var config float HostMigrationTimeout;
var transient PhysicsVolume FirstPhysicsVolume;

replication
{
    // Pos:0x000
    if(bNetDirty && Role == ROLE_Authority)
        Pauser, ReplicatedMusicTrack, 
        TimeDilation, WorldGravityZ, 
        bHighPriorityLoading
}

// Export UWorldInfo::execReleaseCachedConstraintsAndEvaluators(FFrame&, void* const)
native function ReleaseCachedConstraintsAndEvaluators();

// Export UWorldInfo::execGetNavMeshPathConstraintFromCache(FFrame&, void* const)
native function NavMeshPathConstraint GetNavMeshPathConstraintFromCache(class<NavMeshPathConstraint> ConstraintClass, NavigationHandle Requestor);

// Export UWorldInfo::execGetNavMeshPathGoalEvaluatorFromCache(FFrame&, void* const)
native function NavMeshPathGoalEvaluator GetNavMeshPathGoalEvaluatorFromCache(class<NavMeshPathGoalEvaluator> GoalEvalClass, NavigationHandle Requestor);

simulated event ReplicatedEvent(name VarName)
{
    // End:0x2A
    if(VarName == 'ReplicatedMusicTrack')
    {
        UpdateMusicTrack(ReplicatedMusicTrack);
    }
    super(Actor).ReplicatedEvent(VarName);
    //return;    
}

// Export UWorldInfo::execAddOnScreenDebugMessage(FFrame&, void* const)
native final function AddOnScreenDebugMessage(int Key, float TimeToDisplay, Color DisplayColor, string DebugMessage);

// Export UWorldInfo::execIsMenuLevel(FFrame&, void* const)
native static final function bool IsMenuLevel(optional string MapName);

// Export UWorldInfo::execSetMusicVolume(FFrame&, void* const)
native final function SetMusicVolume(float VolumeMultiplier);

// Export UWorldInfo::execUpdateMusicTrack(FFrame&, void* const)
native final function UpdateMusicTrack(MusicTrackStruct NewMusicTrack);

// Export UWorldInfo::execGetGravityZ(FFrame&, void* const)
native function float GetGravityZ();

// Export UWorldInfo::execGetGameSequence(FFrame&, void* const)
native final simulated function Sequence GetGameSequence();

// Export UWorldInfo::execGetAllRootSequences(FFrame&, void* const)
native final simulated function array<Sequence> GetAllRootSequences();

// Export UWorldInfo::execSetLevelRBGravity(FFrame&, void* const)
native final function SetLevelRBGravity(Vector NewGrav);

// Export UWorldInfo::execGetLocalURL(FFrame&, void* const)
native simulated function string GetLocalURL();

// Export UWorldInfo::execIsDemoBuild(FFrame&, void* const)
native static final simulated function bool IsDemoBuild();

// Export UWorldInfo::execIsConsoleBuild(FFrame&, void* const)
native static final simulated function bool IsConsoleBuild(optional WorldInfo.EConsoleType ConsoleType)
{
    ConsoleType = 0;            
}

// Export UWorldInfo::execIsWithGFx(FFrame&, void* const)
native static final simulated function bool IsWithGFx();

// Export UWorldInfo::execIsPlayInEditor(FFrame&, void* const)
native static final simulated function bool IsPlayInEditor();

// Export UWorldInfo::execIsPlayInPreview(FFrame&, void* const)
native static final simulated function bool IsPlayInPreview();

// Export UWorldInfo::execIsPlayInMobilePreview(FFrame&, void* const)
native static final simulated function bool IsPlayInMobilePreview();

// Export UWorldInfo::execForceGarbageCollection(FFrame&, void* const)
native final simulated function ForceGarbageCollection(optional bool bFullPurge);

// Export UWorldInfo::execVerifyNavList(FFrame&, void* const)
native final simulated function VerifyNavList();

// Export UWorldInfo::execGetAddressURL(FFrame&, void* const)
native simulated function string GetAddressURL();

simulated function class<GameInfo> GetGameClass()
{
    // End:0x58
    if(WorldInfo.Game != none)
    {
        return WorldInfo.Game.Class;
    }
    // End:0xAC
    if((GRI != none) && GRI.GameClass != none)
    {
        return GRI.GameClass;
    }
    return none;
    //return ReturnValue;    
}

simulated event ServerTravel(string URL, optional bool bAbsolute, optional bool bShouldSkipGameNotify)
{
    // End:0x43
    if(InStr(URL, "%") >= 0)
    {
        LogInternal("URL Contains illegal character '%'.");
        return;
    }
    // End:0x9E
    if(((InStr(URL, ":") >= 0) || InStr(URL, "/") >= 0) || InStr(URL, "\\") >= 0)
    {
        LogInternal("URL blocked");
        return;
    }
    // End:0xFE
    if((Game != none) && Game.bHasNetworkError)
    {
        LogInternal("Not traveling because of network error");
        return;
    }
    NextTravelType = ((bAbsolute) ? 0 : 2);
    // End:0x1C0
    if((NextURL == "") && !IsInSeamlessTravel() || bShouldSkipGameNotify)
    {
        NextURL = URL;
        // End:0x1B1
        if(Game != none)
        {
            // End:0x1AE
            if(!bShouldSkipGameNotify)
            {
                Game.ProcessServerTravel(URL, bAbsolute);
            }
        }
        // End:0x1C0
        else
        {
            NextSwitchCountdown = 0.0;
        }
    }
    //return;    
}

function ThisIsNeverExecuted(DefaultPhysicsVolume P)
{
    P = none;
    //return;    
}

simulated function PreBeginPlay()
{
    local class<EmitterPool> PoolClass;
    local class<DecalManager> DecalManagerClass;
    local class<FractureManager> FractureManagerClass;
    local class<ParticleEventManager> ParticleEventManagerClass;

    super(Actor).PreBeginPlay();
    // End:0x26B
    if((WorldInfo.NetMode != NM_DedicatedServer) && IsInPersistentLevel())
    {
        // End:0xCD
        if(EmitterPoolClassPath != "")
        {
            PoolClass = class<EmitterPool>(DynamicLoadObject(EmitterPoolClassPath, class'Class'));
            // End:0xCD
            if(PoolClass != none)
            {
                MyEmitterPool = Spawn(PoolClass, self,, vect(0.0, 0.0, 0.0), rot(0, 0, 0));
            }
        }
        // End:0x157
        if(DecalManagerClassPath != "")
        {
            DecalManagerClass = class<DecalManager>(DynamicLoadObject(DecalManagerClassPath, class'Class'));
            // End:0x157
            if(DecalManagerClass != none)
            {
                MyDecalManager = Spawn(DecalManagerClass, self,, vect(0.0, 0.0, 0.0), rot(0, 0, 0));
            }
        }
        // End:0x1E1
        if(FractureManagerClassPath != "")
        {
            FractureManagerClass = class<FractureManager>(DynamicLoadObject(FractureManagerClassPath, class'Class'));
            // End:0x1E1
            if(FractureManagerClass != none)
            {
                MyFractureManager = Spawn(FractureManagerClass, self,, vect(0.0, 0.0, 0.0), rot(0, 0, 0));
            }
        }
        // End:0x26B
        if(ParticleEventManagerClassPath != "")
        {
            ParticleEventManagerClass = class<ParticleEventManager>(DynamicLoadObject(ParticleEventManagerClassPath, class'Class'));
            // End:0x26B
            if(ParticleEventManagerClass != none)
            {
                MyParticleEventManager = Spawn(ParticleEventManagerClass, self,, vect(0.0, 0.0, 0.0), rot(0, 0, 0));
            }
        }
    }
    //return;    
}

simulated function PostBeginPlay()
{
    super(Actor).PostBeginPlay();
    // End:0x24
    if(IsConsoleBuild())
    {
        bUseConsoleInput = true;
    }
    //return;    
}

function Reset()
{
    super(Actor).Reset();
    //return;    
}

// Export UWorldInfo::execAllNavigationPoints(FFrame&, void* const)
native final iterator function AllNavigationPoints(class<NavigationPoint> BaseClass, out NavigationPoint N);

// Export UWorldInfo::execRadiusNavigationPoints(FFrame&, void* const)
native final iterator function RadiusNavigationPoints(class<NavigationPoint> BaseClass, out NavigationPoint N, Vector Point, float Radius);

// Export UWorldInfo::execNavigationPointCheck(FFrame&, void* const)
native final function NavigationPointCheck(Vector Point, Vector Extent, optional out array<NavigationPoint> Navs, optional out array<ReachSpec> Specs);

// Export UWorldInfo::execAllControllers(FFrame&, void* const)
native final iterator function AllControllers(class<Controller> BaseClass, out Controller C);

// Export UWorldInfo::execAllPawns(FFrame&, void* const)
native final iterator function AllPawns(class<Pawn> BaseClass, out Pawn P, optional Vector TestLocation, optional float TestRadius);

// Export UWorldInfo::execAllClientConnections(FFrame&, void* const)
native final iterator function AllClientConnections(out Player ClientConnection, out IpAddr ClientIP, out int ClientPort);

// Export UWorldInfo::execNotifyMatchStarted(FFrame&, void* const)
native final function NotifyMatchStarted(optional bool bShouldActivateLevelStartupEvents, optional bool bShouldActivateLevelBeginningEvents, optional bool bShouldActivateLevelLoadedEvents)
{
    bShouldActivateLevelStartupEvents = true;
    bShouldActivateLevelBeginningEvents = true;
    bShouldActivateLevelLoadedEvents = false;                    
}

// Export UWorldInfo::execPrepareMapChange(FFrame&, void* const)
native final function PrepareMapChange(const out array<name> LevelNames);

// Export UWorldInfo::execIsPreparingMapChange(FFrame&, void* const)
native final function bool IsPreparingMapChange();

// Export UWorldInfo::execIsMapChangeReady(FFrame&, void* const)
native final function bool IsMapChangeReady();

// Export UWorldInfo::execCancelPendingMapChange(FFrame&, void* const)
native final function CancelPendingMapChange();

// Export UWorldInfo::execCommitMapChange(FFrame&, void* const)
native final function CommitMapChange();

// Export UWorldInfo::execSeamlessTravel(FFrame&, void* const)
native final function SeamlessTravel(string URL, optional bool bAbsolute, init optional Guid MapPackageGuid);

// Export UWorldInfo::execIsInSeamlessTravel(FFrame&, void* const)
native final function bool IsInSeamlessTravel();

// Export UWorldInfo::execSetSeamlessTravelMidpointPause(FFrame&, void* const)
native final function SetSeamlessTravelMidpointPause(bool bNowPaused);

// Export UWorldInfo::execGetMapInfo(FFrame&, void* const)
native final function MapInfo GetMapInfo();

// Export UWorldInfo::execSetMapInfo(FFrame&, void* const)
native final function SetMapInfo(MapInfo NewMapInfo);

// Export UWorldInfo::execGetMapName(FFrame&, void* const)
native final function string GetMapName(optional bool bIncludePrefix);

// Export UWorldInfo::execGetDetailMode(FFrame&, void* const)
native final function Scene.EDetailMode GetDetailMode();

// Export UWorldInfo::execIsRecordingDemo(FFrame&, void* const)
native final function bool IsRecordingDemo();

// Export UWorldInfo::execIsPlayingDemo(FFrame&, void* const)
native final function bool IsPlayingDemo();

// Export UWorldInfo::execGetDemoFrameInfo(FFrame&, void* const)
native final function GetDemoFrameInfo(optional out int CurrentFrame, optional out int TotalFrames);

// Export UWorldInfo::execGetDemoRewindPoints(FFrame&, void* const)
native final function bool GetDemoRewindPoints(out array<int> OutRewindPoints);

// Export UWorldInfo::execDoMemoryTracking(FFrame&, void* const)
native final function DoMemoryTracking();

// Export UWorldInfo::execGetWorldFractureSettings(FFrame&, void* const)
native final function WorldFractureSettings GetWorldFractureSettings();

// Export UWorldInfo::execGetWorldInfo(FFrame&, void* const)
native static final function WorldInfo GetWorldInfo();

// Export UWorldInfo::execFindEnvironmentVolume(FFrame&, void* const)
native final function EnvironmentVolume FindEnvironmentVolume(Vector TestLocation);

simulated event bool CanBeginHostMigration()
{
    local PlayerController PC;

    // End:0x90
    foreach LocalPlayerControllers(class'PlayerController', PC)
    {
        // End:0x8F
        if(PC.IsPrimaryPlayer())
        {
            // End:0x8F
            if(!PC.CanAllPlayersPlayOnline() || PC.BestNextHostPeers.Length == 0)
            {                
                return false;
            }
        }        
    }    
    return true;
    //return ReturnValue;    
}

// Export UWorldInfo::execBeginHostMigration(FFrame&, void* const)
native function bool BeginHostMigration();

simulated event NotifyHostMigrationStateChanged(WorldInfo.EHostMigrationProgress NewState, WorldInfo.EHostMigrationProgress OldState)
{
    local PlayerController PC;

    // End:0x8F
    if((OldState == 0) && NewState != 0)
    {
        // End:0x8E
        foreach LocalPlayerControllers(class'PlayerController', PC)
        {
            // End:0x8D
            if(PC.IsPrimaryPlayer())
            {
                PC.NotifyHostMigrationStarted();
                // End:0x8E
                break;
            }            
        }        
    }
    //return;    
}

// Export UWorldInfo::execToggleHostMigration(FFrame&, void* const)
native function ToggleHostMigration(bool bEnabled);

// Export UWorldInfo::execClearObjectPools(FFrame&, void* const)
native final function ClearObjectPools();

defaultproperties
{
    DefaultPostProcessSettings=(bOverride_EnableBloom=true,bOverride_EnableDOF=true,bOverride_EnableMotionBlur=true,bOverride_EnableSceneEffect=true,bOverride_AllowAmbientOcclusion=true,bOverride_OverrideRimShaderColor=true,bOverride_Bloom_Scale=true,bOverride_Bloom_Threshold=true,bOverride_Bloom_Tint=true,bOverride_Bloom_ScreenBlendThreshold=true,bOverride_Bloom_InterpolationDuration=true,bOverride_DOF_FalloffExponent=true,bOverride_DOF_BlurKernelSize=true,bOverride_DOF_BlurBloomKernelSize=true,bOverride_DOF_MaxNearBlurAmount=true,bOverride_DOF_MinBlurAmount=false,bOverride_DOF_MaxFarBlurAmount=true,bOverride_DOF_FocusType=true,bOverride_DOF_FocusInnerRadius=true,bOverride_DOF_FocusDistance=true,bOverride_DOF_FocusPosition=true,bOverride_DOF_InterpolationDuration=true,bOverride_DOF_BokehTexture=false,bOverride_MotionBlur_MaxVelocity=false,bOverride_MotionBlur_Amount=false,bOverride_MotionBlur_FullMotionBlur=false,bOverride_MotionBlur_CameraRotationThreshold=false,bOverride_MotionBlur_CameraTranslationThreshold=false,bOverride_MotionBlur_InterpolationDuration=false,bOverride_Scene_Desaturation=true,bOverride_Scene_Colorize=false,bOverride_Scene_TonemapperScale=false,bOverride_Scene_ImageGrainScale=false,bOverride_Scene_HighLights=true,bOverride_Scene_MidTones=true,bOverride_Scene_Shadows=true,bOverride_Scene_InterpolationDuration=true,bOverride_Scene_ColorGradingLUT=false,bOverride_RimShader_Color=true,bOverride_RimShader_InterpolationDuration=true,bOverride_MobileColorGrading=false,bEnableBloom=false,bEnableDOF=false,bEnableMotionBlur=false,bEnableSceneEffect=false,bAllowAmbientOcclusion=true,bOverrideRimShaderColor=false,Bloom_Scale=1.0,Bloom_Threshold=1.0,Bloom_Tint=(R=255,G=255,B=255,A=0),Bloom_ScreenBlendThreshold=10.0,Bloom_InterpolationDuration=1.0,DOF_BlurBloomKernelSize=16.0,DOF_FalloffExponent=4.0,DOF_BlurKernelSize=16.0,DOF_MaxNearBlurAmount=1.0,DOF_MinBlurAmount=0.0,DOF_MaxFarBlurAmount=1.0,DOF_FocusType=EFocusType.FOCUS_Distance,DOF_FocusInnerRadius=2000.0,DOF_FocusDistance=0.0,DOF_FocusPosition=(X=0.0,Y=0.0,Z=0.0),DOF_InterpolationDuration=1.0,DOF_BokehTexture=none,MotionBlur_MaxVelocity=1.0,MotionBlur_Amount=0.50,MotionBlur_FullMotionBlur=true,MotionBlur_CameraRotationThreshold=45.0,MotionBlur_CameraTranslationThreshold=10000.0,MotionBlur_InterpolationDuration=1.0,Scene_Desaturation=0.0,Scene_Colorize=(X=1.0,Y=1.0,Z=1.0),Scene_TonemapperScale=1.0,Scene_ImageGrainScale=0.0,Scene_HighLights=(X=1.0,Y=1.0,Z=1.0),Scene_MidTones=(X=1.0,Y=1.0,Z=1.0),Scene_Shadows=(X=0.0,Y=0.0,Z=0.0),Scene_InterpolationDuration=1.0,RimShader_Color=(R=0.8277260,G=0.5859730,B=0.470440,A=1.0),RimShader_InterpolationDuration=1.0,ColorGrading_LookupTable=none,ColorGradingLUT=(LUTTextures=none,LUTWeights=none),MobileColorGrading=(TransitionTime=1.0,Blend=0.0,Desaturation=0.0,HighLights=(R=0.70,G=0.70,B=0.70,A=1.0),MidTones=(R=0.0,G=0.0,B=0.0,A=1.0),Shadows=(R=0.0,G=0.0,B=0.0,A=1.0)),MobilePostProcess=(bOverride_Mobile_BlurAmount=false,bOverride_Mobile_TransitionTime=false,bOverride_Mobile_Bloom_Scale=false,bOverride_Mobile_Bloom_Threshold=false,bOverride_Mobile_Bloom_Tint=false,bOverride_Mobile_DOF_Distance=false,bOverride_Mobile_DOF_MinRange=false,bOverride_Mobile_DOF_MaxRange=false,bOverride_Mobile_DOF_NearBlurFactor=false,bOverride_Mobile_DOF_FarBlurFactor=false,Mobile_BlurAmount=16.0,Mobile_TransitionTime=1.0,Mobile_Bloom_Scale=6.0,Mobile_Bloom_Threshold=0.50,Mobile_Bloom_Tint=(R=1.0,G=1.0,B=1.0,A=1.0),Mobile_DOF_Distance=1500.0,Mobile_DOF_MinRange=600.0,Mobile_DOF_MaxRange=1200.0,Mobile_DOF_NearBlurFactor=1.0,Mobile_DOF_FarBlurFactor=1.0),TotalWeight_Bloom=0.0,TotalWeight_DOF=0.0,TotalWeight_MotionBlur=0.0,TotalWeight_Scene=0.0)
    bPersistPostProcessToNextLevel=true
    bBumpOffsetEnabled=true
    bNoMobileMapWarnings=true
    bPlaceCellsOnSurfaces=true
    bAllowTemporalAA=true
    bUseGlobalIllumination=true
    SquintModeKernelSize=128.0
    DefaultReverbSettings=(bApplyReverb=true,ReverbType=ReverbPreset.REVERB_Default,Volume=0.50,FadeTime=2.0)
    DefaultAmbientZoneSettings=(bIsWorldInfo=true,ExteriorVolume=1.0,ExteriorTime=0.50,ExteriorLPF=1.0,ExteriorLPFTime=0.50,InteriorVolume=1.0,InteriorTime=0.50,InteriorLPF=1.0,InteriorLPFTime=0.50)
    FogStart=400.0
    FogEnd=4000.0
    FogColor=(R=128,G=128,B=255,A=192)
    BumpEnd=1000.0
    TimeDilation=1.0
    DemoPlayTimeDilation=1.0
    VisibleLayers="None"
    DefaultTexture=Texture2D'EngineResources.DefaultTexture'
    WhiteSquareTexture=Texture2D'EngineResources.WhiteSquareTexture'
    LargeVertex=Texture2D'EditorResources.LargeVertex'
    BSPVertex=Texture2D'EditorResources.BSPVertex'
    NextTravelType=ETravelType.TRAVEL_Relative
    LevelLightingQuality=ELightingBuildQuality.None
    StallZ=1000000.0
    DefaultGravityZ=-750.0
    RBPhysicsGravityScaling=1.0
    MoveRepSize=42.0
    PackedLightAndShadowMapTextureSize=1024
    DefaultColorScale=(X=1.0,Y=1.0,Z=1.0)
    CurrentMusicTrack=(TheSoundCue=none,bAutoPlay=false,bPersistentAcrossLevels=false,FadeInTime=5.0,FadeInVolumeLevel=1.0,FadeOutTime=5.0,FadeOutVolumeLevel=0.0,MP3Filename="")
    ReplicatedMusicTrack=(TheSoundCue=none,bAutoPlay=false,bPersistentAcrossLevels=false,FadeInTime=5.0,FadeInVolumeLevel=1.0,FadeOutTime=5.0,FadeOutVolumeLevel=0.0,MP3Filename="")
    EmitterPoolClassPath="Engine.EmitterPool"
    DecalManagerClassPath="Engine.DecalManager"
    FractureManagerClassPath="Engine.FractureManager"
    MaxPhysicsDeltaTime=0.33333330
    MaxPhysicsSubsteps=5
    PhysicsProperties=(PrimaryScene=(bUseHardware=false,bFixedTimeStep=false,TimeStep=0.020,MaxSubSteps=5),CompartmentRigidBody=(bUseHardware=false,bFixedTimeStep=false,TimeStep=0.020,MaxSubSteps=2),CompartmentFluid=(bUseHardware=true,bFixedTimeStep=false,TimeStep=0.020,MaxSubSteps=1),CompartmentCloth=(bUseHardware=true,bFixedTimeStep=true,TimeStep=0.020,MaxSubSteps=2),CompartmentSoftBody=(bUseHardware=true,bFixedTimeStep=true,TimeStep=0.020,MaxSubSteps=2))
    DefaultSkinWidth=0.0250
    ApexLODResourceBudget=-1.0
    ApexDestructionLODResourceValue=1000.0
    ApexClothingLODResourceValue=1000.0
    DestructibleSettings=(MaxChunkIslandCount=-1,MaxShapeCount=-1,MaxRrbActorCount=-1,MaxChunkSeparationLOD=1.0,bOverrideMaxChunkSeparationLOD=false)
    EmitterVertical=PhysicsLODVerticalEmitter'Default__WorldInfo.PhysicsLODVerticalEmitter0'
    VerticalProperties=(Emitters=(bDisableLod=true,ParticlesLodMin=0,ParticlesLodMax=15000,PacketsPerPhysXParticleSystemMax=500,bApplyCylindricalPacketCulling=true,SpawnLodVsFifoBias=1.0))
    ChanceOfPhysicsChunkOverride=1.0
    FractureExplosionVelScale=1.0
    MaxNumFacturedChunksToSpawnInAFrame=12
    FracturedMeshWeaponDamage=1.0
    VisibilityCellSize=200
    CharacterLitIndirectBrightness=1.0
    CharacterLitIndirectContrastFactor=1.0
    CharacterShadowedIndirectBrightness=1.0
    CharacterShadowedIndirectContrastFactor=1.0
    CharacterLightingContrastFactor=1.50
    ImageReflectionEnvironmentColor=(R=1.0,G=1.0,B=1.0,A=1.0)
    MaxTrianglesPerLeaf=4
    LightmassSettings=(StaticLightingLevelScale=1.0,NumIndirectLightingBounces=3,EnvironmentColor=(R=0,G=0,B=0,A=0),EnvironmentIntensity=1.0,bEnableAdvancedEnvironmentColor=false,EnvironmentSunColor=(R=0,G=0,B=0,A=0),EnvironmentSunIntensity=1.0,EnvironmentLightTerminatorAngle=90.0,EnvironmentLightDirection=(X=0.0,Y=0.0,Z=0.0),EmissiveBoost=1.0,DiffuseBoost=5.0,SpecularBoost=1.0,IndirectNormalInfluenceBoost=0.30,bUseAmbientOcclusion=false,bEnableImageReflectionShadowing=false,DirectIlluminationOcclusionFraction=0.50,IndirectIlluminationOcclusionFraction=1.0,OcclusionExponent=1.0,FullyOccludedSamplesFraction=1.0,MaxOcclusionDistance=200.0,bVisualizeMaterialDiffuse=false,bVisualizeAmbientOcclusion=false,bCompressShadowmap=false)
    HostMigrationTimeout=15.0
    Components=none
    RemoteRole=ENetRole.ROLE_SimulatedProxy
    bWorldGeometry=true
    bAlwaysRelevant=true
    bMovable=false
    bBlockActors=true
    bHiddenEd=true
}