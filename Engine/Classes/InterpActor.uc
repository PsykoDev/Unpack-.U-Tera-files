/*******************************************************************************
 * InterpActor generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2015 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class InterpActor extends DynamicSMActor
    native
    placeable
    hidecategories(Navigation)
    classgroup(Common);

struct CheckpointRecord
{
    var Vector Location;
    var Rotator Rotation;
    var Actor.ECollisionType CollisionType;
    var bool bHidden;
    var bool bIsShutdown;
    var bool bNeedsPositionReplication;

    structdefaultproperties
    {
        Location=(X=0.0,Y=0.0,Z=0.0)
        Rotation=(Pitch=0,Yaw=0,Roll=0)
        CollisionType=ECollisionType.COLLIDE_CustomDefault
        bHidden=false
        bIsShutdown=false
        bNeedsPositionReplication=false
    }
};

var bool bShouldSaveForCheckpoint;
var bool bMonitorMover;
var bool bMonitorZVelocity;
/** if set this mover blows up projectiles when it encroaches them */
var() bool bDestroyProjectilesOnEncroach;
/** if set, this mover keeps going if it encroaches an Actor in PHYS_RigidBody. */
var() bool bContinueOnEncroachPhysicsObject;
/** true by default, prevents mover from completing the movement that would leave it encroaching another actor */
var() bool bStopOnEncroach;
/**  
 *This is used for having the Actor ShadowParent all of the components that are "SetBased" onto it.  This allows LDs to
 * take InterpActors in the level and then SetBase a ton of other meshes to them and not incur multiple shadow casters.
 */
var() bool bShouldShadowParentAllAttachedActors;
var bool bIsLift;
var NavigationPoint MyMarker;
var float MaxZVelocity;
var float StayOpenTime;
/** sound played when the mover is interpolated forward */
var() SoundCue OpenSound;
/** looping sound while opening */
var() SoundCue OpeningAmbientSound;
/** sound played when mover finished moving forward */
var() SoundCue OpenedSound;
/** sound played when the mover is interpolated in reverse */
var() SoundCue CloseSound;
/** looping sound while closing */
var() SoundCue ClosingAmbientSound;
/** sound played when mover finished moving backward */
var() SoundCue ClosedSound;
var export editinline AudioComponent AmbientSoundComponent;

simulated event PostBeginPlay()
{
    super.PostBeginPlay();
    // End:0x33
    if(bShouldShadowParentAllAttachedActors)
    {
        SetShadowParentOnAllAttachedComponents(StaticMeshComponent, LightEnvironment);
    }
    // End:0x7E
    if((OpeningAmbientSound != none) || ClosingAmbientSound != none)
    {
        AmbientSoundComponent = new (self) class'AudioComponent';
        AttachComponent(AmbientSoundComponent);
    }
    // End:0xD2
    if((Base != none) && bHardAttach || (BaseSkelComponent != none) && BaseBoneName != 'None')
    {
        bShouldSaveForCheckpoint = false;
    }
    //return;    
}

event bool EncroachingOn(Actor Other)
{
    local int I;
    local SeqEvent_Mover MoverEvent;
    local Pawn P;
    local Vector Height, HitLocation, HitNormal;
    local bool bLandingPawn;

    // End:0x3A
    if(bContinueOnEncroachPhysicsObject && Other.Physics == 10)
    {
        return false;
    }
    // End:0x76
    if(Other.bDestroyedByInterpActor)
    {
        Other.Destroy();
        return false;
    }
    // End:0x4F2
    if((Other.Base == self) || (Normal(Velocity) Dot Normal(Other.Location - Location)) >= 0.0)
    {
        P = Pawn(Other);
        // End:0x3C3
        if(P != none)
        {
            // End:0x2BA
            if((P.Physics == 2) && Velocity.Z > 0.0)
            {
                Height = P.GetCollisionHeight() * vect(0.0, 0.0, 1.0);
                // End:0x2B7
                if(TraceComponent(HitLocation, HitNormal, StaticMeshComponent, P.Location - Height, P.Location + Height, P.GetCollisionExtent()))
                {
                    // End:0x2AB
                    if(P.Location.Z < Location.Z)
                    {
                        P.SetLocation(HitLocation + Height);
                    }
                    bLandingPawn = true;
                }
            }
            // End:0x3C0
            else
            {
                // End:0x3C0
                if((((P.Base != self) && P.Controller != none) && P.Controller.PendingMover != none) && P.Controller.PendingMover == self)
                {
                    P.Controller.UnderLift(LiftCenter(MyMarker));
                }
            }
        }
        // End:0x44A
        else
        {
            // End:0x44A
            if(bDestroyProjectilesOnEncroach && Other.IsA('Projectile'))
            {
                Projectile(Other).Explode(Other.Location, -Normal(Velocity));
                return false;
            }
        }
        // End:0x4F2
        if(!bLandingPawn)
        {
            I = 0;
            J0x464:
            // End:0x4E7 [Loop If]
            if(I < GeneratedEvents.Length)
            {
                MoverEvent = SeqEvent_Mover(GeneratedEvents[I]);
                // End:0x4D9
                if(MoverEvent != none)
                {
                    MoverEvent.NotifyEncroachingOn(Other);
                }
                ++ I;
                // [Loop Continue]
                goto J0x464;
            }
            return bStopOnEncroach;
        }
    }
    return false;
    //return ReturnValue;    
}

event RanInto(Actor Other)
{
    local int I;
    local SeqEvent_Mover MoverEvent;

    // End:0x88
    if(bDestroyProjectilesOnEncroach && Other.IsA('Projectile'))
    {
        Projectile(Other).Explode(Other.Location, -Normal(Velocity));
    }
    // End:0x165
    else
    {
        // End:0xC5
        if(Other.bDestroyedByInterpActor)
        {
            Other.Destroy();
        }
        // End:0x165
        else
        {
            // End:0xD7
            if(bIsLift)
            {
                return;
            }
            // End:0x165
            else
            {
                I = 0;
                J0xE2:
                // End:0x165 [Loop If]
                if(I < GeneratedEvents.Length)
                {
                    MoverEvent = SeqEvent_Mover(GeneratedEvents[I]);
                    // End:0x157
                    if(MoverEvent != none)
                    {
                        MoverEvent.NotifyEncroachingOn(Other);
                    }
                    ++ I;
                    // [Loop Continue]
                    goto J0xE2;
                }
            }
        }
    }
    //return;    
}

event Attach(Actor Other)
{
    local int I;
    local SeqEvent_Mover MoverEvent;

    // End:0xA7
    if(!IsTimerActive('FinishedOpen'))
    {
        I = 0;
        J0x24:
        // End:0xA7 [Loop If]
        if(I < GeneratedEvents.Length)
        {
            MoverEvent = SeqEvent_Mover(GeneratedEvents[I]);
            // End:0x99
            if(MoverEvent != none)
            {
                MoverEvent.NotifyAttached(Other);
            }
            ++ I;
            // [Loop Continue]
            goto J0x24;
        }
    }
    //return;    
}

event Detach(Actor Other)
{
    local int I;
    local SeqEvent_Mover MoverEvent;

    I = 0;
    J0x0B:
    // End:0x8E [Loop If]
    if(I < GeneratedEvents.Length)
    {
        MoverEvent = SeqEvent_Mover(GeneratedEvents[I]);
        // End:0x80
        if(MoverEvent != none)
        {
            MoverEvent.NotifyDetached(Other);
        }
        ++ I;
        // [Loop Continue]
        goto J0x0B;
    }
    //return;    
}

function Restart()
{
    local Actor A;

    // End:0x2C
    foreach BasedActors(class'Actor', A)
    {
        Attach(A);        
    }    
    //return;    
}

function FinishedOpen()
{
    local int I;
    local SeqEvent_Mover MoverEvent;

    I = 0;
    J0x0B:
    // End:0x85 [Loop If]
    if(I < GeneratedEvents.Length)
    {
        MoverEvent = SeqEvent_Mover(GeneratedEvents[I]);
        // End:0x77
        if(MoverEvent != none)
        {
            MoverEvent.NotifyFinishedOpen();
        }
        ++ I;
        // [Loop Continue]
        goto J0x0B;
    }
    //return;    
}

simulated function PlayMovingSound(bool bClosing)
{
    local SoundCue SoundToPlay, AmbientToPlay;

    // End:0x36
    if(bClosing)
    {
        SoundToPlay = CloseSound;
        AmbientToPlay = OpeningAmbientSound;
    }
    // End:0x5C
    else
    {
        SoundToPlay = OpenSound;
        AmbientToPlay = ClosingAmbientSound;
    }
    // End:0x83
    if(SoundToPlay != none)
    {
        PlaySound(SoundToPlay, true);
    }
    // End:0xF9
    if(AmbientToPlay != none)
    {
        AmbientSoundComponent.Stop();
        AmbientSoundComponent.SoundCue = AmbientToPlay;
        AmbientSoundComponent.Play();
    }
    //return;    
}

simulated event InterpolationStarted(SeqAct_Interp InterpAction, InterpGroupInst GroupInst)
{
    ClearTimer('Restart');
    ClearTimer('FinishedOpen');
    PlayMovingSound(InterpAction.bReversePlayback);
    bShouldSaveForCheckpoint = true;
    //return;    
}

simulated event InterpolationFinished(SeqAct_Interp InterpAction)
{
    local DoorMarker DoorNav;
    local Controller C;
    local SoundCue StoppedSound;

    // End:0x2E
    if(AmbientSoundComponent != none)
    {
        AmbientSoundComponent.Stop();
    }
    StoppedSound = ((InterpAction.bReversePlayback) ? ClosedSound : OpenedSound);
    // End:0x95
    if(StoppedSound != none)
    {
        PlaySound(StoppedSound, true);
    }
    DoorNav = DoorMarker(MyMarker);
    // End:0x12B
    if(InterpAction.bReversePlayback)
    {
        // End:0xFA
        if(Attached.Length > 0)
        {
            SetTimer(StayOpenTime, false, 'Restart');
        }
        // End:0x128
        if(DoorNav != none)
        {
            DoorNav.MoverClosed();
        }
    }
    // End:0x170
    else
    {
        SetTimer(StayOpenTime, false, 'FinishedOpen');
        // End:0x170
        if(DoorNav != none)
        {
            DoorNav.MoverOpened();
        }
    }
    // End:0x1F6
    if(bMonitorMover)
    {
        // End:0x1F5
        foreach WorldInfo.AllControllers(class'Controller', C)
        {
            // End:0x1F4
            if(C.PendingMover == self)
            {
                C.MoverFinished();
            }            
        }        
    }
    // End:0x25E
    if(InterpAction.bNoResetOnRewind && InterpAction.bRewindOnPlay)
    {
        ForceNetRelevant();
        bUpdateSimulatedPosition = true;
        bReplicateMovement = true;
    }
    //return;    
}

simulated event InterpolationChanged(SeqAct_Interp InterpAction)
{
    PlayMovingSound(InterpAction.bReversePlayback);
    //return;    
}

simulated function ShutDown()
{
    super(Actor).ShutDown();
    bShouldSaveForCheckpoint = true;
    //return;    
}

function bool ShouldSaveForCheckpoint()
{
    return bShouldSaveForCheckpoint || RemoteRole == ROLE_SimulatedProxy;
    //return ReturnValue;    
}

function CreateCheckpointRecord(out CheckpointRecord Record)
{
    Record.Location = Location;
    Record.Rotation = Rotation;
    Record.bHidden = bHidden;
    Record.CollisionType = ReplicatedCollisionType;
    Record.bNeedsPositionReplication = (RemoteRole == ROLE_SimulatedProxy) && bUpdateSimulatedPosition;
    Record.bIsShutdown = (Physics == 0) && bHidden;
    //return;    
}

function ApplyCheckpointRecord(const out CheckpointRecord Record)
{
    local Actor OldBase;
    local editinline SkeletalMeshComponent OldBaseComp;
    local name OldBaseBoneName;
    local array<Actor> OldAttached;
    local array<Vector> OldLocations;
    local int I;

    // End:0x2D
    if(Record.bIsShutdown)
    {
        ShutDown();
    }
    // End:0x362
    else
    {
        OldAttached = Attached;
        J0x40:
        // End:0x101 [Loop If]
        if(I < OldAttached.Length)
        {
            // End:0xE9
            if((OldAttached[I] != none) && OldAttached[I].bJustTeleported)
            {
                OldLocations[I] = OldAttached[I].Location;
                ++ I;
            }
            // End:0xFE
            else
            {
                OldAttached.Remove(I, 1);
            }
            // [Loop Continue]
            goto J0x40;
        }
        OldBase = Base;
        OldBaseComp = BaseSkelComponent;
        OldBaseBoneName = BaseBoneName;
        SetLocation(Record.Location);
        SetRotation(Record.Rotation);
        SetBase(OldBase,, OldBaseComp, OldBaseBoneName);
        I = 0;
        J0x1A2:
        // End:0x23C [Loop If]
        if(I < OldAttached.Length)
        {
            // End:0x22E
            if(OldAttached[I] != none)
            {
                OldAttached[I].SetLocation(OldLocations[I]);
                OldAttached[I].SetBase(self);
            }
            ++ I;
            // [Loop Continue]
            goto J0x1A2;
        }
        // End:0x29A
        if(Record.CollisionType != ReplicatedCollisionType)
        {
            SetCollisionType(Record.CollisionType);
            ForceNetRelevant();
        }
        // End:0x320
        if(Record.bHidden != bHidden)
        {
            SetHidden(Record.bHidden);
            SetForcedInitialReplicatedProperty(boolproperty'bHidden', bHidden == default.bHidden);
            ForceNetRelevant();
        }
        // End:0x362
        if(Record.bNeedsPositionReplication)
        {
            bUpdateSimulatedPosition = true;
            bReplicateMovement = true;
            ForceNetRelevant();
        }
    }
    bShouldSaveForCheckpoint = true;
    //return;    
}

defaultproperties
{
    bShouldSaveForCheckpoint=true
    bDestroyProjectilesOnEncroach=true
    bContinueOnEncroachPhysicsObject=true
    bStopOnEncroach=true
    bShouldShadowParentAllAttachedActors=true
    begin object name=StaticMeshComponent0 class=StaticMeshComponent
        WireframeColor=(R=255,G=0,B=255,A=255)
        ReplacementPrimitive=none
        LightEnvironment=DynamicLightEnvironmentComponent'Default__InterpActor.MyLightEnvironment'
        RBCollideWithChannels=(Default=true,BlockingVolume=true)
    object end
    // Reference: StaticMeshComponent'Default__InterpActor.StaticMeshComponent0'
    StaticMeshComponent=StaticMeshComponent0
    LightEnvironment=DynamicLightEnvironmentComponent'Default__InterpActor.MyLightEnvironment'
    Components(0)=DynamicLightEnvironmentComponent'Default__InterpActor.MyLightEnvironment'
    begin object name=StaticMeshComponent0 class=StaticMeshComponent
        WireframeColor=(R=255,G=0,B=255,A=255)
        ReplacementPrimitive=none
        LightEnvironment=DynamicLightEnvironmentComponent'Default__InterpActor.MyLightEnvironment'
        RBCollideWithChannels=(Default=true,BlockingVolume=true)
    object end
    // Reference: StaticMeshComponent'Default__InterpActor.StaticMeshComponent0'
    Components(1)=StaticMeshComponent0
    Physics=EPhysics.PHYS_Interpolating
    RemoteRole=ENetRole.ROLE_None
    bNoDelete=true
    bAlwaysRelevant=true
    bOnlyDirtyReplication=true
    bBlocksTeleport=true
    NetUpdateFrequency=1.0
    NetPriority=2.70
    begin object name=StaticMeshComponent0 class=StaticMeshComponent
        WireframeColor=(R=255,G=0,B=255,A=255)
        ReplacementPrimitive=none
        LightEnvironment=DynamicLightEnvironmentComponent'Default__InterpActor.MyLightEnvironment'
        RBCollideWithChannels=(Default=true,BlockingVolume=true)
    object end
    // Reference: StaticMeshComponent'Default__InterpActor.StaticMeshComponent0'
    CollisionComponent=StaticMeshComponent0
    SupportedEvents(0)=class'SeqEvent_Touch'
    SupportedEvents(1)=class'SeqEvent_Destroyed'
    SupportedEvents(2)=class'SeqEvent_TakeDamage'
    SupportedEvents(3)=class'SeqEvent_HitWall'
    SupportedEvents(4)=class'SeqEvent_AnimNotify'
    SupportedEvents(5)=class'SeqEvent_MobileTouch'
    SupportedEvents(6)=class'SeqEvent_Mover'
}