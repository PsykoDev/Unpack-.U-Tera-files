/*******************************************************************************
 * LadderVolume generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2015 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class LadderVolume extends PhysicsVolume
    native
    placeable
    hidecategories(Navigation,Object,Movement,Display);

var() Rotator WallDir;
var Vector LookDir;
var Vector ClimbDir;
var const Ladder LadderList;
/** if true, won't push into/keep player against geometry in lookdir */
var() bool bNoPhysicalLadder;
/** add top and bottom ladders automatically */
var() bool bAutoPath;
/** if true, players on ladder can strafe sideways */
var() bool bAllowLadderStrafing;
var Pawn PendingClimber;
var export editinline ArrowComponent WallDirArrow;

simulated event PostBeginPlay()
{
    local Ladder L, M;
    local Vector Dir;

    super.PostBeginPlay();
    LookDir = vector(WallDir);
    // End:0x1EF
    if(!bAutoPath && LookDir.Z != float(0))
    {
        ClimbDir = vect(0.0, 0.0, 1.0);
        L = LadderList;
        J0x7E:
        // End:0x1A8 [Loop If]
        if(L != none)
        {
            M = LadderList;
            J0xA0:
            // End:0x17D [Loop If]
            if(M != none)
            {
                // End:0x152
                if(M != L)
                {
                    Dir = Normal(M.Location - L.Location);
                    // End:0x13E
                    if((Dir Dot ClimbDir) < float(0))
                    {
                        Dir *= float(-1);
                    }
                    ClimbDir += Dir;
                }
                M = M.LadderList;
                // [Loop Continue]
                goto J0xA0;
            }
            L = L.LadderList;
            // [Loop Continue]
            goto J0x7E;
        }
        ClimbDir = Normal(ClimbDir);
        // End:0x1EF
        if((ClimbDir Dot vect(0.0, 0.0, 1.0)) < float(0))
        {
            ClimbDir *= float(-1);
        }
    }
    //return;    
}

function bool InUse(Pawn Ignored)
{
    local Pawn StillClimbing;

    // End:0x7B
    foreach TouchingActors(class'Pawn', StillClimbing)
    {
        // End:0x7A
        if(((StillClimbing != Ignored) && StillClimbing.bCollideActors) && StillClimbing.bBlockActors)
        {            
            return true;
        }        
    }    
    // End:0x1A3
    if(PendingClimber != none)
    {
        // End:0x1A3
        if(((((PendingClimber.Controller == none) || !PendingClimber.bCollideActors) || !PendingClimber.bBlockActors) || Ladder(PendingClimber.Controller.MoveTarget) == none) || Ladder(PendingClimber.Controller.MoveTarget).MyLadder != self)
        {
            PendingClimber = none;
        }
    }
    return (PendingClimber != none) && PendingClimber != Ignored;
    //return ReturnValue;    
}

simulated event PawnEnteredVolume(Pawn P)
{
    local Rotator PawnRot;

    super.PawnEnteredVolume(P);
    // End:0x39
    if(!P.CanGrabLadder())
    {
        return;
    }
    PawnRot = P.Rotation;
    PawnRot.Pitch = 0;
    // End:0x135
    if(((vector(PawnRot) Dot LookDir) > 0.90) || (AIController(P.Controller) != none) && Ladder(P.Controller.MoveTarget) != none)
    {
        P.ClimbLadder(self);
    }
    // End:0x1A0
    else
    {
        // End:0x1A0
        if(!P.bDeleteMe && P.Controller != none)
        {
            Spawn(class'PotentialClimbWatcher', P);
        }
    }
    //return;    
}

simulated event PawnLeavingVolume(Pawn P)
{
    local Controller C;

    // End:0x26
    if(P.OnLadder != self)
    {
        return;
    }
    super.PawnLeavingVolume(P);
    P.OnLadder = none;
    P.EndClimbLadder(self);
    // End:0x9B
    if(P == PendingClimber)
    {
        PendingClimber = none;
    }
    // End:0x1CA
    if(!InUse(P))
    {
        // End:0x1C9
        foreach WorldInfo.AllControllers(class'Controller', C)
        {
            // End:0x1C8
            if((C.bPreparingMove && Ladder(C.MoveTarget) != none) && Ladder(C.MoveTarget).MyLadder == self)
            {
                C.bPreparingMove = false;
                PendingClimber = C.Pawn;                
                return;
            }            
        }        
    }
    //return;    
}

simulated event PhysicsChangedFor(Actor Other)
{
    // End:0xC3
    if(((((Other.Physics == 2) || Other.Physics == 9) || Other.bDeleteMe) || Pawn(Other) == none) || Pawn(Other).Controller == none)
    {
        return;
    }
    Spawn(class'PotentialClimbWatcher', Other);
    //return;    
}

defaultproperties
{
    ClimbDir=(X=0.0,Y=0.0,Z=1.0)
    bAutoPath=true
    bAllowLadderStrafing=true
    begin object name=Arrow class=ArrowComponent
        ArrowColor=(R=150,G=100,B=150,A=255)
        ArrowSize=5.0
        ReplacementPrimitive=none
    object end
    // Reference: ArrowComponent'Default__LadderVolume.Arrow'
    WallDirArrow=Arrow
    begin object name=BrushComponent0 class=BrushComponent
        ReplacementPrimitive=none
    object end
    // Reference: BrushComponent'Default__LadderVolume.BrushComponent0'
    BrushComponent=BrushComponent0
    begin object name=BrushComponent0 class=BrushComponent
        ReplacementPrimitive=none
    object end
    // Reference: BrushComponent'Default__LadderVolume.BrushComponent0'
    Components(0)=BrushComponent0
    begin object name=Arrow class=ArrowComponent
        ArrowColor=(R=150,G=100,B=150,A=255)
        ArrowSize=5.0
        ReplacementPrimitive=none
    object end
    // Reference: ArrowComponent'Default__LadderVolume.Arrow'
    Components(1)=Arrow
    RemoteRole=ENetRole.ROLE_SimulatedProxy
    begin object name=BrushComponent0 class=BrushComponent
        ReplacementPrimitive=none
    object end
    // Reference: BrushComponent'Default__LadderVolume.BrushComponent0'
    CollisionComponent=BrushComponent0
}