/*******************************************************************************
 * PlayerInput generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2015 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class PlayerInput extends Input within PlayerController
    transient
    native(UserInterface)
    config(Input)
    hidecategories(Object,UIRoot);

var const bool bUsingGamepad;
var globalconfig bool bInvertMouse;
var globalconfig bool bInvertTurn;
var bool bWasForward;
var bool bWasBack;
var bool bWasLeft;
var bool bWasRight;
var bool bEdgeForward;
var bool bEdgeBack;
var bool bEdgeLeft;
var bool bEdgeRight;
var globalconfig bool bEnableMouseSmoothing;
var bool bEnableFOVScaling;
var transient bool bLockTurnUntilRelease;
var const name LastAxisKeyName;
var float DoubleClickTimer;
var globalconfig float DoubleClickTime;
var globalconfig float MouseSensitivity;
var input float aBaseX;
var input float aBaseY;
var input float aBaseZ;
var input float aMouseX;
var input float aMouseY;
var input float aForward;
var input float aTurn;
var input float aStrafe;
var input float aUp;
var input float aLookUp;
var input float aRightAnalogTrigger;
var input float aLeftAnalogTrigger;
var input float aPS3AccelX;
var input float aPS3AccelY;
var input float aPS3AccelZ;
var input float aPS3Gyro;
var input float aWiiUPointerX;
var input float aWiiUPointerY;
var input Vector aTilt;
var input Vector aRotationRate;
var input Vector aGravity;
var input Vector aAcceleration;
var input Vector aTouch[5];
var input Vector aBackTouch[5];
var transient float RawJoyUp;
var transient float RawJoyRight;
var transient float RawJoyLookRight;
var transient float RawJoyLookUp;
/** move forward speed scaling */
var() config float MoveForwardSpeed;
/** strafe speed scaling */
var() config float MoveStrafeSpeed;
/** Yaw turn speed scaling */
var() config float LookRightScale;
/** pitch turn speed scaling */
var() config float LookUpScale;
var input byte bStrafe;
var input byte bXAxis;
var input byte bYAxis;
var float ZeroTime[2];
var float SmoothedMouse[2];
var int MouseSamples;
var float MouseSamplingTotal;
var transient float AutoUnlockTurnTime;

// Export UPlayerInput::execCancelMobileInput(FFrame&, void* const)
native function CancelMobileInput();

exec function bool InvertMouse()
{
    bInvertMouse = !bInvertMouse;
    SaveConfig();
    return bInvertMouse;
    //return ReturnValue;    
}

exec function bool InvertTurn()
{
    bInvertTurn = !bInvertTurn;
    SaveConfig();
    return bInvertTurn;
    //return ReturnValue;    
}

exec function SetSensitivity(float F)
{
    MouseSensitivity = F;
    //return;    
}

function DrawHUD(HUD H)
{
    //return;    
}

function PreProcessInput(float DeltaTime)
{
    //return;    
}

function PostProcessInput(float DeltaTime)
{
    //return;    
}

function AdjustMouseSensitivity(float FOVScale)
{
    aMouseX *= (MouseSensitivity * FOVScale);
    aMouseY *= (MouseSensitivity * FOVScale);
    //return;    
}

event PlayerInput(float DeltaTime)
{
    local float FOVScale, TimeScale;

    RawJoyUp = aBaseY;
    RawJoyRight = aStrafe;
    RawJoyLookRight = aTurn;
    RawJoyLookUp = aLookUp;
    DeltaTime /= Outer.WorldInfo.TimeDilation;
    // End:0x12A
    if(Outer.bDemoOwner && Outer.WorldInfo.NetMode == NM_Client)
    {
        DeltaTime /= Outer.WorldInfo.DemoPlayTimeDilation;
    }
    PreProcessInput(DeltaTime);
    TimeScale = 100.0 * DeltaTime;
    aBaseY *= (TimeScale * MoveForwardSpeed);
    aStrafe *= (TimeScale * MoveStrafeSpeed);
    aUp *= (TimeScale * MoveStrafeSpeed);
    aTurn *= (TimeScale * LookRightScale);
    aLookUp *= (TimeScale * LookUpScale);
    PostProcessInput(DeltaTime);
    ProcessInputMatching(DeltaTime);
    CatchDoubleClickInput();
    // End:0x262
    if(bEnableFOVScaling)
    {
        FOVScale = Outer.GetFOVAngle() * 0.011110;
    }
    // End:0x271
    else
    {
        FOVScale = 1.0;
    }
    AdjustMouseSensitivity(FOVScale);
    // End:0x2F1
    if(bEnableMouseSmoothing)
    {
        aMouseX = SmoothMouse(aMouseX, DeltaTime, bXAxis, 0);
        aMouseY = SmoothMouse(aMouseY, DeltaTime, bYAxis, 1);
    }
    aLookUp *= FOVScale;
    aTurn *= FOVScale;
    // End:0x34F
    if(bStrafe > 0)
    {
        aStrafe += (aBaseX + aMouseX);
    }
    // End:0x36E
    else
    {
        aTurn += (aBaseX + aMouseX);
    }
    aLookUp += aMouseY;
    // End:0x39F
    if(bInvertMouse)
    {
        aLookUp *= -1.0;
    }
    // End:0x3BC
    if(bInvertTurn)
    {
        aTurn *= -1.0;
    }
    aForward += aBaseY;
    Outer.HandleWalking();
    // End:0x471
    if(bLockTurnUntilRelease)
    {
        // End:0x465
        if(RawJoyLookRight != float(0))
        {
            aTurn = 0.0;
            // End:0x462
            if(AutoUnlockTurnTime > 0.0)
            {
                AutoUnlockTurnTime -= DeltaTime;
                // End:0x462
                if(AutoUnlockTurnTime < 0.0)
                {
                    bLockTurnUntilRelease = false;
                }
            }
        }
        // End:0x471
        else
        {
            bLockTurnUntilRelease = false;
        }
    }
    // End:0x4C0
    if(Outer.IsMoveInputIgnored())
    {
        aForward = 0.0;
        aStrafe = 0.0;
        aUp = 0.0;
    }
    // End:0x500
    if(Outer.IsLookInputIgnored())
    {
        aTurn = 0.0;
        aLookUp = 0.0;
    }
    //return;    
}

function CatchDoubleClickInput()
{
    // End:0x11C
    if(!Outer.IsMoveInputIgnored())
    {
        bEdgeForward = bWasForward ^^ (aBaseY > float(0));
        bEdgeBack = bWasBack ^^ (aBaseY < float(0));
        bEdgeLeft = bWasLeft ^^ (aStrafe < float(0));
        bEdgeRight = bWasRight ^^ (aStrafe > float(0));
        bWasForward = aBaseY > float(0);
        bWasBack = aBaseY < float(0);
        bWasLeft = aStrafe < float(0);
        bWasRight = aStrafe > float(0);
    }
    //return;    
}

function Actor.EDoubleClickDir CheckForDoubleClickMove(float DeltaTime)
{
    local Actor.EDoubleClickDir DoubleClickMove, OldDoubleClick;

    // End:0x38
    if(Outer.DoubleClickDir == 5)
    {
        DoubleClickMove = 5;
    }
    // End:0x44
    else
    {
        DoubleClickMove = 0;
    }
    // End:0x49F
    if(DoubleClickTime > 0.0)
    {
        // End:0x117
        if(Outer.DoubleClickDir == 5)
        {
            // End:0x114
            if((Outer.Pawn != none) && Outer.Pawn.Physics == 1)
            {
                DoubleClickTimer = 0.0;
                Outer.DoubleClickDir = 6;
            }
        }
        // End:0x35A
        else
        {
            // End:0x35A
            if(Outer.DoubleClickDir != 6)
            {
                OldDoubleClick = Outer.DoubleClickDir;
                Outer.DoubleClickDir = 0;
                // End:0x1C9
                if(bEdgeForward && bWasForward)
                {
                    Outer.DoubleClickDir = 3;
                }
                // End:0x286
                else
                {
                    // End:0x209
                    if(bEdgeBack && bWasBack)
                    {
                        Outer.DoubleClickDir = 4;
                    }
                    // End:0x286
                    else
                    {
                        // End:0x249
                        if(bEdgeLeft && bWasLeft)
                        {
                            Outer.DoubleClickDir = 1;
                        }
                        // End:0x286
                        else
                        {
                            // End:0x286
                            if(bEdgeRight && bWasRight)
                            {
                                Outer.DoubleClickDir = 2;
                            }
                        }
                    }
                }
                // End:0x2DA
                if(Outer.DoubleClickDir == 0)
                {
                    Outer.DoubleClickDir = OldDoubleClick;
                }
                // End:0x35A
                else
                {
                    // End:0x332
                    if(Outer.DoubleClickDir != OldDoubleClick)
                    {
                        DoubleClickTimer = DoubleClickTime + (0.50 * DeltaTime);
                    }
                    // End:0x35A
                    else
                    {
                        DoubleClickMove = Outer.DoubleClickDir;
                    }
                }
            }
        }
        // End:0x3F2
        if(Outer.DoubleClickDir == 6)
        {
            DoubleClickTimer = FMin(DoubleClickTimer - DeltaTime, 0.0);
            // End:0x3EF
            if(DoubleClickTimer < -0.350)
            {
                Outer.DoubleClickDir = 0;
                DoubleClickTimer = DoubleClickTime;
            }
        }
        // End:0x49F
        else
        {
            // End:0x49F
            if((Outer.DoubleClickDir != 0) && Outer.DoubleClickDir != 5)
            {
                DoubleClickTimer -= DeltaTime;
                // End:0x49F
                if(DoubleClickTimer < float(0))
                {
                    Outer.DoubleClickDir = 0;
                    DoubleClickTimer = DoubleClickTime;
                }
            }
        }
    }
    return DoubleClickMove;
    //return ReturnValue;    
}

final function ProcessInputMatching(float DeltaTime)
{
    local float Value;
    local int I, MatchIdx;
    local bool bMatch;

    I = 0;
    J0x0B:
    // End:0x9AE [Loop If]
    if(I < Outer.InputRequests.Length)
    {
        // End:0x9A0
        if((Outer.InputRequests[I].MatchIdx >= 0) && Outer.InputRequests[I].MatchIdx < Outer.InputRequests[I].Inputs.Length)
        {
            // End:0x17D
            if(Outer.InputRequests[I].MatchActor == none)
            {
                Outer.InputRequests[I].MatchActor = Outer;
            }
            MatchIdx = Outer.InputRequests[I].MatchIdx;
            // End:0x45A
            if(((MatchIdx != 0) && Outer.InputRequests[I].Inputs[MatchIdx].TimeDelta > 0.0) && (Outer.WorldInfo.TimeSeconds - Outer.InputRequests[I].LastMatchTime) >= Outer.InputRequests[I].Inputs[MatchIdx].TimeDelta)
            {
                Outer.InputRequests[I].LastMatchTime = 0.0;
                Outer.InputRequests[I].MatchIdx = 0;
                // End:0x457
                if(Outer.InputRequests[I].FailedFuncName != 'None')
                {
                    Outer.InputRequests[I].MatchActor.SetTimer(0.010, false, Outer.InputRequests[I].FailedFuncName);
                }
            }
            // End:0x9A0
            else
            {
                Value = 0.0;
                switch(Outer.InputRequests[I].Inputs[MatchIdx].Type)
                {
                    // End:0x4E6
                    case 0:
                        Value = aStrafe;
                        // End:0x504
                        break;
                    // End:0x501
                    case 1:
                        Value = aBaseY;
                        // End:0x504
                        break;
                    // End:0xFFFF
                    default:
                        switch(Outer.InputRequests[I].Inputs[MatchIdx].Action)
                        {
                            // End:0x5DC
                            case 0:
                                bMatch = Value >= Outer.InputRequests[I].Inputs[MatchIdx].Value;
                                // End:0x655
                                break;
                            // End:0x652
                            case 1:
                                bMatch = Value <= Outer.InputRequests[I].Inputs[MatchIdx].Value;
                                // End:0x655
                                break;
                            // End:0xFFFF
                            default:
                                // End:0x9A0
                                if(bMatch)
                                {
                                    Outer.InputRequests[I].LastMatchTime = Outer.WorldInfo.TimeSeconds;
                                    ++ Outer.InputRequests[I].MatchIdx;
                                    // End:0x9A0
                                    if(Outer.InputRequests[I].MatchIdx >= Outer.InputRequests[I].Inputs.Length)
                                    {
                                        // End:0x84D
                                        if(Outer.InputRequests[I].MatchDelegate != none)
                                        {
                                            Outer.__InputMatchDelegate__Delegate = Outer.InputRequests[I].MatchDelegate;
                                            Outer.InputMatchDelegate();
                                        }
                                        // End:0x922
                                        if(Outer.InputRequests[I].MatchFuncName != 'None')
                                        {
                                            Outer.InputRequests[I].MatchActor.SetTimer(0.010, false, Outer.InputRequests[I].MatchFuncName);
                                        }
                                        Outer.InputRequests[I].LastMatchTime = 0.0;
                                        Outer.InputRequests[I].MatchIdx = 0;
                                    }
                                }
                            }
                        }
                        ++ I;
                        // [Loop Continue]
                        goto J0x0B;
                    }
                    //return;                    
}

exec function Jump()
{
    // End:0x7A
    if(Outer.WorldInfo.Pauser == Outer.PlayerReplicationInfo)
    {
        Outer.SetPause(false);
    }
    // End:0x9B
    else
    {
        Outer.bPressedJump = true;
    }
    //return;    
}

exec function SmartJump()
{
    Jump();
    //return;    
}

exec function ClearSmoothing()
{
    local int I;

    I = 0;
    J0x0B:
    // End:0x5B [Loop If]
    if(I < 2)
    {
        ZeroTime[I] = 0.0;
        SmoothedMouse[I] = 0.0;
        ++ I;
        // [Loop Continue]
        goto J0x0B;
    }
    MouseSamplingTotal = default.MouseSamplingTotal;
    MouseSamples = default.MouseSamples;
    //return;    
}

function float SmoothMouse(float aMouse, float DeltaTime, out byte SampleCount, int Index)
{
    local float MouseSamplingTime;

    // End:0x1BB
    if(DeltaTime < 0.250)
    {
        MouseSamplingTime = MouseSamplingTotal / float(MouseSamples);
        // End:0xD5
        if(aMouse == float(0))
        {
            ZeroTime[Index] += DeltaTime;
            // End:0xB9
            if(ZeroTime[Index] < MouseSamplingTime)
            {
                aMouse = (SmoothedMouse[Index] * DeltaTime) / MouseSamplingTime;
            }
            // End:0xD2
            else
            {
                SmoothedMouse[Index] = 0.0;
            }
        }
        // End:0x1B8
        else
        {
            ZeroTime[Index] = 0.0;
            // End:0x18E
            if(SmoothedMouse[Index] != float(0))
            {
                // End:0x16E
                if(DeltaTime < (MouseSamplingTime * float(SampleCount + 1)))
                {
                    aMouse = (aMouse * DeltaTime) / (MouseSamplingTime * float(SampleCount));
                }
                // End:0x18E
                else
                {
                    SampleCount = byte(DeltaTime / MouseSamplingTime);
                }
            }
            SmoothedMouse[Index] = aMouse / float(SampleCount);
        }
    }
    // End:0x1C5
    else
    {
        ClearSmoothing();
    }
    SampleCount = 0;
    return aMouse;
    //return ReturnValue;    
}

// Export UPlayerInput::execInitInputSystem(FFrame&, void* const)
native function InitInputSystem();

function ClientInitInputSystem()
{
    //return;    
}

function PreClientTravel(string PendingURL, Actor.ETravelType TravelType, bool bIsSeamlessTravel)
{
    //return;    
}

defaultproperties
{
    bEnableMouseSmoothing=true
    DoubleClickTime=0.250
    MouseSensitivity=60.0
    MoveForwardSpeed=1200.0
    MoveStrafeSpeed=1200.0
    LookRightScale=300.0
    LookUpScale=-250.0
    MouseSamples=1
    MouseSamplingTotal=0.00830
}