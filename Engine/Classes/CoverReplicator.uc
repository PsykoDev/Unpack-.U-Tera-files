/*******************************************************************************
 * CoverReplicator generated by Eliot.UELib using UE Explorer.
 * Eliot.UELib ? 2009-2015 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class CoverReplicator extends ReplicationInfo
    notplaceable
    hidecategories(Navigation,Movement,Collision);

struct ManualCoverTypeInfo
{
    var byte SlotIndex;
    var CoverLink.ECoverType ManualCoverType;

    structdefaultproperties
    {
        SlotIndex=0
        ManualCoverType=ECoverType.CT_None
    }
};

struct CoverReplicationInfo
{
    var CoverLink Link;
    var array<byte> SlotsEnabled;
    var array<byte> SlotsDisabled;
    var array<byte> SlotsAdjusted;
    var array<ManualCoverTypeInfo> SlotsCoverTypeChanged;

    structdefaultproperties
    {
        Link=none
        SlotsEnabled=none
        SlotsDisabled=none
        SlotsAdjusted=none
        SlotsCoverTypeChanged=none
    }
};

var array<CoverReplicationInfo> CoverReplicationData;

function PurgeOldEntries()
{
    local int I;

    I = 0;
    J0x0B:
    // End:0x74 [Loop If]
    if(I < CoverReplicationData.Length)
    {
        // End:0x66
        if(CoverReplicationData[I].Link == none)
        {
            CoverReplicationData.Remove(-- I, 1);
        }
        ++ I;
        // [Loop Continue]
        goto J0x0B;
    }
    //return;    
}

function ReplicateInitialCoverInfo()
{
    local CoverReplicator CoverReplicatorBase;

    CoverReplicatorBase = WorldInfo.Game.GetCoverReplicator();
    CoverReplicatorBase.PurgeOldEntries();
    CoverReplicationData = CoverReplicatorBase.CoverReplicationData;
    // End:0xC4
    if(PlayerController(Owner) != none)
    {
        ClientSetOwner(PlayerController(Owner));
        ServerSendInitialCoverReplicationInfo(0);
    }
    //return;    
}

reliable client simulated function ClientSetOwner(PlayerController PC)
{
    SetOwner(PC);
    //return;    
}

reliable server function ServerSendInitialCoverReplicationInfo(int Index)
{
    local byte SlotsArrayIndex, NumSlotsEnabled, NumSlotsDisabled, NumSlotsAdjusted, NumCoverTypesChanged, SlotsEnabled,
	    SlotsDisabled, SlotsAdjusted;

    local ManualCoverTypeInfo SlotsCoverTypeChanged[8];
    local int I;
    local bool bDone;


    J0x00:    // End:0x5E [Loop If]
    if((Index < CoverReplicationData.Length) && CoverReplicationData[Index].Link == none)
    {
        CoverReplicationData.Remove(Index, 1);
        // [Loop Continue]
        goto J0x00;
    }
    // End:0x711
    if(Index < CoverReplicationData.Length)
    {
        SlotsArrayIndex = 0;
        NumSlotsEnabled = byte(Clamp(CoverReplicationData[Index].SlotsEnabled.Length - SlotsArrayIndex, 0, 8));
        NumSlotsDisabled = byte(Clamp(CoverReplicationData[Index].SlotsDisabled.Length - SlotsArrayIndex, 0, 8));
        NumSlotsAdjusted = byte(Clamp(CoverReplicationData[Index].SlotsAdjusted.Length - SlotsArrayIndex, 0, 8));
        NumCoverTypesChanged = byte(Clamp(CoverReplicationData[Index].SlotsCoverTypeChanged.Length - SlotsArrayIndex, 0, 8));
        // End:0x1EC
        if(NumSlotsEnabled == 0)
        {
            I = 0;
            J0x1B5:
            // End:0x1E9 [Loop If]
            if(I < 8)
            {
                SlotsEnabled[I] = 0;
                ++ I;
                // [Loop Continue]
                goto J0x1B5;
            }
        }
        // End:0x26F
        else
        {
            I = 0;
            J0x1F7:
            // End:0x26F [Loop If]
            if(I < NumSlotsEnabled)
            {
                SlotsEnabled[I] = CoverReplicationData[Index].SlotsEnabled[SlotsArrayIndex + I];
                ++ I;
                // [Loop Continue]
                goto J0x1F7;
            }
        }
        // End:0x2C5
        if(NumSlotsDisabled == 0)
        {
            I = 0;
            J0x28E:
            // End:0x2C2 [Loop If]
            if(I < 8)
            {
                SlotsDisabled[I] = 0;
                ++ I;
                // [Loop Continue]
                goto J0x28E;
            }
        }
        // End:0x348
        else
        {
            I = 0;
            J0x2D0:
            // End:0x348 [Loop If]
            if(I < NumSlotsDisabled)
            {
                SlotsDisabled[I] = CoverReplicationData[Index].SlotsDisabled[SlotsArrayIndex + I];
                ++ I;
                // [Loop Continue]
                goto J0x2D0;
            }
        }
        // End:0x39E
        if(NumSlotsAdjusted == 0)
        {
            I = 0;
            J0x367:
            // End:0x39B [Loop If]
            if(I < 8)
            {
                SlotsAdjusted[I] = 0;
                ++ I;
                // [Loop Continue]
                goto J0x367;
            }
        }
        // End:0x421
        else
        {
            I = 0;
            J0x3A9:
            // End:0x421 [Loop If]
            if(I < NumSlotsAdjusted)
            {
                SlotsAdjusted[I] = CoverReplicationData[Index].SlotsAdjusted[SlotsArrayIndex + I];
                ++ I;
                // [Loop Continue]
                goto J0x3A9;
            }
        }
        // End:0x4B3
        if(NumCoverTypesChanged == 0)
        {
            I = 0;
            J0x440:
            // End:0x4B0 [Loop If]
            if(I < 8)
            {
                SlotsCoverTypeChanged[I].SlotIndex = 0;
                SlotsCoverTypeChanged[I].ManualCoverType = 0;
                ++ I;
                // [Loop Continue]
                goto J0x440;
            }
        }
        // End:0x536
        else
        {
            I = 0;
            J0x4BE:
            // End:0x536 [Loop If]
            if(I < NumCoverTypesChanged)
            {
                SlotsCoverTypeChanged[I] = CoverReplicationData[Index].SlotsCoverTypeChanged[SlotsArrayIndex + I];
                ++ I;
                // [Loop Continue]
                goto J0x4BE;
            }
        }
        bDone = ((((CoverReplicationData[Index].SlotsEnabled.Length - SlotsArrayIndex) <= 8) && (CoverReplicationData[Index].SlotsDisabled.Length - SlotsArrayIndex) <= 8) && (CoverReplicationData[Index].SlotsAdjusted.Length - SlotsArrayIndex) <= 8) && (CoverReplicationData[Index].SlotsCoverTypeChanged.Length - SlotsArrayIndex) <= 8;
        ClientReceiveInitialCoverReplicationInfo(Index, CoverReplicationData[Index].Link, CoverReplicationData[Index].Link.bDisabled, NumSlotsEnabled, SlotsEnabled, NumSlotsDisabled, SlotsDisabled, NumSlotsAdjusted, SlotsAdjusted, NumCoverTypesChanged, SlotsCoverTypeChanged, bDone);
        SlotsArrayIndex += 8;
        // End:0x82
        if(bDone)
            goto J0x82;
    }
    //return;    
}

reliable client simulated function ClientReceiveInitialCoverReplicationInfo(int Index, CoverLink Link, bool bLinkDisabled, byte NumSlotsEnabled, byte SlotsEnabled[8], byte NumSlotsDisabled, byte SlotsDisabled[8], byte NumSlotsAdjusted, byte SlotsAdjusted[8], byte NumCoverTypesChanged, ManualCoverTypeInfo SlotsCoverTypeChanged[8], bool bDone)
{
    local int I;

    // End:0x32
    if(Link == none)
    {
        // End:0x2F
        if(bDone)
        {
            ServerSendInitialCoverReplicationInfo(Index);
        }
    }
    // End:0x4EB
    else
    {
        Link.bDisabled = bLinkDisabled;
        I = 0;
        J0x67:
        // End:0xC3 [Loop If]
        if(I < NumSlotsEnabled)
        {
            Link.SetSlotEnabled(SlotsEnabled[I], true);
            ++ I;
            // [Loop Continue]
            goto J0x67;
        }
        I = 0;
        J0xCE:
        // End:0x12A [Loop If]
        if(I < NumSlotsDisabled)
        {
            Link.SetSlotEnabled(SlotsDisabled[I], false);
            ++ I;
            // [Loop Continue]
            goto J0xCE;
        }
        I = 0;
        J0x135:
        // End:0x2B9 [Loop If]
        if(I < NumSlotsAdjusted)
        {
            // End:0x2AB
            if((Link.AutoAdjustSlot(SlotsAdjusted[I], false) && Link.Slots[SlotsAdjusted[I]].SlotOwner != none) && Link.Slots[SlotsAdjusted[I]].SlotOwner.Controller != none)
            {
                Link.Slots[SlotsAdjusted[I]].SlotOwner.Controller.NotifyCoverAdjusted();
            }
            ++ I;
            // [Loop Continue]
            goto J0x135;
        }
        I = 0;
        J0x2C4:
        // End:0x4C8 [Loop If]
        if(I < NumCoverTypesChanged)
        {
            Link.Slots[SlotsCoverTypeChanged[I].SlotIndex].CoverType = SlotsCoverTypeChanged[I].ManualCoverType;
            // End:0x4BA
            if((Link.Slots[SlotsCoverTypeChanged[I].SlotIndex].SlotOwner != none) && Link.Slots[SlotsCoverTypeChanged[I].SlotIndex].SlotOwner.Controller != none)
            {
                Link.Slots[SlotsCoverTypeChanged[I].SlotIndex].SlotOwner.Controller.NotifyCoverAdjusted();
            }
            ++ I;
            // [Loop Continue]
            goto J0x2C4;
        }
        // End:0x4EB
        if(bDone)
        {
            ServerSendInitialCoverReplicationInfo(Index + 1);
        }
    }
    //return;    
}

function NotifyEnabledSlots(CoverLink Link, const out array<int> SlotIndices)
{
    local int Index, SlotIndex, I;
    local PlayerController PC;

    Index = CoverReplicationData.Find('Link', Link);
    // End:0x112
    if(Index == -1)
    {
        Index = CoverReplicationData.Length;
        CoverReplicationData.Length = CoverReplicationData.Length + 1;
        CoverReplicationData[Index].Link = Link;
        I = 0;
        J0xA3:
        // End:0x10F [Loop If]
        if(I < SlotIndices.Length)
        {
            CoverReplicationData[Index].SlotsEnabled[I] = byte(SlotIndices[I]);
            ++ I;
            // [Loop Continue]
            goto J0xA3;
        }
    }
    // End:0x291
    else
    {
        I = 0;
        J0x11D:
        // End:0x291 [Loop If]
        if(I < SlotIndices.Length)
        {
            SlotIndex = CoverReplicationData[Index].SlotsEnabled.Find(byte(SlotIndices[I]));
            // End:0x1F5
            if(SlotIndex == -1)
            {
                CoverReplicationData[Index].SlotsEnabled[CoverReplicationData[Index].SlotsEnabled.Length] = byte(SlotIndices[I]);
            }
            SlotIndex = CoverReplicationData[Index].SlotsDisabled.Find(byte(SlotIndices[I]));
            // End:0x283
            if(SlotIndex != -1)
            {
                CoverReplicationData[Index].SlotsDisabled.Remove(SlotIndex, 1);
            }
            ++ I;
            // [Loop Continue]
            goto J0x11D;
        }
    }
    // End:0x38D
    if(WorldInfo.Game.GetCoverReplicator() == self)
    {
        // End:0x38C
        foreach WorldInfo.AllControllers(class'PlayerController', PC)
        {
            // End:0x345
            if(PC.MyCoverReplicator == none)
            {
                PC.SpawnCoverReplicator();
                // End:0x38B
                continue;
            }
            PC.MyCoverReplicator.NotifyEnabledSlots(Link, SlotIndices);            
        }        
    }
    // End:0x3B8
    if(PlayerController(Owner) != none)
    {
        ServerSendEnabledSlots(Index);
    }
    //return;    
}

reliable server function ServerSendEnabledSlots(int Index)
{
    local int SlotsArrayIndex;
    local byte NumSlotsEnabled, SlotsEnabled;
    local int I;
    local bool bDone;

    // End:0x1AB
    if(CoverReplicationData[Index].Link != none)
    {
        SlotsArrayIndex = 0;
        NumSlotsEnabled = byte(Clamp(CoverReplicationData[Index].SlotsEnabled.Length - SlotsArrayIndex, 0, 8));
        I = 0;
        J0x85:
        // End:0xFB [Loop If]
        if(I < NumSlotsEnabled)
        {
            SlotsEnabled[I] = CoverReplicationData[Index].SlotsEnabled[SlotsArrayIndex + I];
            ++ I;
            // [Loop Continue]
            goto J0x85;
        }
        bDone = (CoverReplicationData[Index].SlotsEnabled.Length - SlotsArrayIndex) <= 8;
        ClientReceiveEnabledSlots(Index, CoverReplicationData[Index].Link, NumSlotsEnabled, SlotsEnabled, bDone);
        SlotsArrayIndex += 8;
        // End:0x37
        if(bDone)
            goto J0x37;
    }
    //return;    
}

reliable client simulated function ClientReceiveEnabledSlots(int Index, CoverLink Link, byte NumSlotsEnabled, byte SlotsEnabled[8], bool bDone)
{
    local int I;

    // End:0x32
    if(Link == none)
    {
        // End:0x2F
        if(bDone)
        {
            ServerSendEnabledSlots(Index);
        }
    }
    // End:0x99
    else
    {
        I = 0;
        J0x3D:
        // End:0x99 [Loop If]
        if(I < NumSlotsEnabled)
        {
            Link.SetSlotEnabled(SlotsEnabled[I], true);
            ++ I;
            // [Loop Continue]
            goto J0x3D;
        }
    }
    //return;    
}

function NotifyDisabledSlots(CoverLink Link, const out array<int> SlotIndices)
{
    local int Index, SlotIndex, I;
    local PlayerController PC;

    Index = CoverReplicationData.Find('Link', Link);
    // End:0x112
    if(Index == -1)
    {
        Index = CoverReplicationData.Length;
        CoverReplicationData.Length = CoverReplicationData.Length + 1;
        CoverReplicationData[Index].Link = Link;
        I = 0;
        J0xA3:
        // End:0x10F [Loop If]
        if(I < SlotIndices.Length)
        {
            CoverReplicationData[Index].SlotsDisabled[I] = byte(SlotIndices[I]);
            ++ I;
            // [Loop Continue]
            goto J0xA3;
        }
    }
    // End:0x291
    else
    {
        I = 0;
        J0x11D:
        // End:0x291 [Loop If]
        if(I < SlotIndices.Length)
        {
            SlotIndex = CoverReplicationData[Index].SlotsDisabled.Find(byte(SlotIndices[I]));
            // End:0x1F5
            if(SlotIndex == -1)
            {
                CoverReplicationData[Index].SlotsDisabled[CoverReplicationData[Index].SlotsDisabled.Length] = byte(SlotIndices[I]);
            }
            SlotIndex = CoverReplicationData[Index].SlotsEnabled.Find(byte(SlotIndices[I]));
            // End:0x283
            if(SlotIndex != -1)
            {
                CoverReplicationData[Index].SlotsEnabled.Remove(SlotIndex, 1);
            }
            ++ I;
            // [Loop Continue]
            goto J0x11D;
        }
    }
    // End:0x38D
    if(WorldInfo.Game.GetCoverReplicator() == self)
    {
        // End:0x38C
        foreach WorldInfo.AllControllers(class'PlayerController', PC)
        {
            // End:0x345
            if(PC.MyCoverReplicator == none)
            {
                PC.SpawnCoverReplicator();
                // End:0x38B
                continue;
            }
            PC.MyCoverReplicator.NotifyDisabledSlots(Link, SlotIndices);            
        }        
    }
    // End:0x3B8
    if(PlayerController(Owner) != none)
    {
        ServerSendDisabledSlots(Index);
    }
    //return;    
}

reliable server function ServerSendDisabledSlots(int Index)
{
    local int SlotsArrayIndex;
    local byte NumSlotsDisabled, SlotsDisabled;
    local int I;
    local bool bDone;

    // End:0x1AB
    if(CoverReplicationData[Index].Link != none)
    {
        SlotsArrayIndex = 0;
        NumSlotsDisabled = byte(Clamp(CoverReplicationData[Index].SlotsDisabled.Length - SlotsArrayIndex, 0, 8));
        I = 0;
        J0x85:
        // End:0xFB [Loop If]
        if(I < NumSlotsDisabled)
        {
            SlotsDisabled[I] = CoverReplicationData[Index].SlotsDisabled[SlotsArrayIndex + I];
            ++ I;
            // [Loop Continue]
            goto J0x85;
        }
        bDone = (CoverReplicationData[Index].SlotsDisabled.Length - SlotsArrayIndex) <= 8;
        ClientReceiveDisabledSlots(Index, CoverReplicationData[Index].Link, NumSlotsDisabled, SlotsDisabled, bDone);
        SlotsArrayIndex += 8;
        // End:0x37
        if(bDone)
            goto J0x37;
    }
    //return;    
}

reliable client simulated function ClientReceiveDisabledSlots(int Index, CoverLink Link, byte NumSlotsDisabled, byte SlotsDisabled[8], bool bDone)
{
    local int I;

    // End:0x32
    if(Link == none)
    {
        // End:0x2F
        if(bDone)
        {
            ServerSendDisabledSlots(Index);
        }
    }
    // End:0x99
    else
    {
        I = 0;
        J0x3D:
        // End:0x99 [Loop If]
        if(I < NumSlotsDisabled)
        {
            Link.SetSlotEnabled(SlotsDisabled[I], false);
            ++ I;
            // [Loop Continue]
            goto J0x3D;
        }
    }
    //return;    
}

function NotifyAutoAdjustSlots(CoverLink Link, const out array<int> SlotIndices)
{
    local int Index, SlotIndex, I;
    local PlayerController PC;

    Index = CoverReplicationData.Find('Link', Link);
    // End:0x112
    if(Index == -1)
    {
        Index = CoverReplicationData.Length;
        CoverReplicationData.Length = CoverReplicationData.Length + 1;
        CoverReplicationData[Index].Link = Link;
        I = 0;
        J0xA3:
        // End:0x10F [Loop If]
        if(I < SlotIndices.Length)
        {
            CoverReplicationData[Index].SlotsAdjusted[I] = byte(SlotIndices[I]);
            ++ I;
            // [Loop Continue]
            goto J0xA3;
        }
    }
    // End:0x29A
    else
    {
        I = 0;
        J0x11D:
        // End:0x29A [Loop If]
        if(I < SlotIndices.Length)
        {
            SlotIndex = CoverReplicationData[Index].SlotsAdjusted.Find(byte(SlotIndices[I]));
            // End:0x1F5
            if(SlotIndex == -1)
            {
                CoverReplicationData[Index].SlotsAdjusted[CoverReplicationData[Index].SlotsAdjusted.Length] = byte(SlotIndices[I]);
            }
            SlotIndex = CoverReplicationData[Index].SlotsCoverTypeChanged.Find('SlotIndex', byte(SlotIndices[I]));
            // End:0x28C
            if(SlotIndex != -1)
            {
                CoverReplicationData[Index].SlotsCoverTypeChanged.Remove(SlotIndex, 1);
            }
            ++ I;
            // [Loop Continue]
            goto J0x11D;
        }
    }
    // End:0x396
    if(WorldInfo.Game.GetCoverReplicator() == self)
    {
        // End:0x395
        foreach WorldInfo.AllControllers(class'PlayerController', PC)
        {
            // End:0x34E
            if(PC.MyCoverReplicator == none)
            {
                PC.SpawnCoverReplicator();
                // End:0x394
                continue;
            }
            PC.MyCoverReplicator.NotifyAutoAdjustSlots(Link, SlotIndices);            
        }        
    }
    // End:0x3C1
    if(PlayerController(Owner) != none)
    {
        ServerSendAdjustedSlots(Index);
    }
    //return;    
}

reliable server function ServerSendAdjustedSlots(int Index)
{
    local int SlotsArrayIndex;
    local byte NumSlotsAdjusted, SlotsAdjusted;
    local int I;
    local bool bDone;

    // End:0x1AB
    if(CoverReplicationData[Index].Link != none)
    {
        SlotsArrayIndex = 0;
        NumSlotsAdjusted = byte(Clamp(CoverReplicationData[Index].SlotsAdjusted.Length - SlotsArrayIndex, 0, 8));
        I = 0;
        J0x85:
        // End:0xFB [Loop If]
        if(I < NumSlotsAdjusted)
        {
            SlotsAdjusted[I] = CoverReplicationData[Index].SlotsAdjusted[SlotsArrayIndex + I];
            ++ I;
            // [Loop Continue]
            goto J0x85;
        }
        bDone = (CoverReplicationData[Index].SlotsAdjusted.Length - SlotsArrayIndex) <= 8;
        ClientReceiveAdjustedSlots(Index, CoverReplicationData[Index].Link, NumSlotsAdjusted, SlotsAdjusted, bDone);
        SlotsArrayIndex += 8;
        // End:0x37
        if(bDone)
            goto J0x37;
    }
    //return;    
}

reliable client simulated function ClientReceiveAdjustedSlots(int Index, CoverLink Link, byte NumSlotsAdjusted, byte SlotsAdjusted[8], bool bDone)
{
    local int I;

    // End:0x32
    if(Link == none)
    {
        // End:0x2F
        if(bDone)
        {
            ServerSendAdjustedSlots(Index);
        }
    }
    // End:0x1C1
    else
    {
        I = 0;
        J0x3D:
        // End:0x1C1 [Loop If]
        if(I < NumSlotsAdjusted)
        {
            // End:0x1B3
            if((Link.AutoAdjustSlot(SlotsAdjusted[I], true) && Link.Slots[SlotsAdjusted[I]].SlotOwner != none) && Link.Slots[SlotsAdjusted[I]].SlotOwner.Controller != none)
            {
                Link.Slots[SlotsAdjusted[I]].SlotOwner.Controller.NotifyCoverAdjusted();
            }
            ++ I;
            // [Loop Continue]
            goto J0x3D;
        }
    }
    //return;    
}

function NotifySetManualCoverTypeForSlots(CoverLink Link, const out array<int> SlotIndices, CoverLink.ECoverType NewCoverType)
{
    local int Index, SlotIndex, I;
    local PlayerController PC;

    Index = CoverReplicationData.Find('Link', Link);
    // End:0x1A4
    if(Index == -1)
    {
        Index = CoverReplicationData.Length;
        CoverReplicationData.Length = CoverReplicationData.Length + 1;
        CoverReplicationData[Index].Link = Link;
        CoverReplicationData[Index].SlotsCoverTypeChanged.Length = SlotIndices.Length;
        I = 0;
        J0xD5:
        // End:0x1A1 [Loop If]
        if(I < SlotIndices.Length)
        {
            CoverReplicationData[Index].SlotsCoverTypeChanged[I].SlotIndex = byte(SlotIndices[I]);
            CoverReplicationData[Index].SlotsCoverTypeChanged[I].ManualCoverType = NewCoverType;
            ++ I;
            // [Loop Continue]
            goto J0xD5;
        }
    }
    // End:0x3F1
    else
    {
        I = 0;
        J0x1AF:
        // End:0x3F1 [Loop If]
        if(I < SlotIndices.Length)
        {
            SlotIndex = CoverReplicationData[Index].SlotsCoverTypeChanged.Find('SlotIndex', byte(SlotIndices[I]));
            // End:0x308
            if(SlotIndex == -1)
            {
                SlotIndex = CoverReplicationData[Index].SlotsCoverTypeChanged.Length;
                CoverReplicationData[Index].SlotsCoverTypeChanged.Length = CoverReplicationData[Index].SlotsCoverTypeChanged.Length + 1;
                CoverReplicationData[Index].SlotsCoverTypeChanged[SlotIndex].SlotIndex = byte(SlotIndices[I]);
            }
            CoverReplicationData[Index].SlotsCoverTypeChanged[SlotIndex].ManualCoverType = NewCoverType;
            SlotIndex = CoverReplicationData[Index].SlotsAdjusted.Find(byte(SlotIndices[I]));
            // End:0x3E3
            if(SlotIndex != -1)
            {
                CoverReplicationData[Index].SlotsAdjusted.Remove(SlotIndex, 1);
            }
            ++ I;
            // [Loop Continue]
            goto J0x1AF;
        }
    }
    // End:0x4F6
    if(WorldInfo.Game.GetCoverReplicator() == self)
    {
        // End:0x4F5
        foreach WorldInfo.AllControllers(class'PlayerController', PC)
        {
            // End:0x4A5
            if(PC.MyCoverReplicator == none)
            {
                PC.SpawnCoverReplicator();
                // End:0x4F4
                continue;
            }
            PC.MyCoverReplicator.NotifySetManualCoverTypeForSlots(Link, SlotIndices, NewCoverType);            
        }        
    }
    // End:0x521
    if(PlayerController(Owner) != none)
    {
        ServerSendManualCoverTypeSlots(Index);
    }
    //return;    
}

reliable server function ServerSendManualCoverTypeSlots(int Index)
{
    local int SlotsArrayIndex;
    local byte NumCoverTypesChanged;
    local ManualCoverTypeInfo SlotsCoverTypeChanged[8];
    local int I;
    local bool bDone;

    // End:0x1AB
    if(CoverReplicationData[Index].Link != none)
    {
        SlotsArrayIndex = 0;
        NumCoverTypesChanged = byte(Clamp(CoverReplicationData[Index].SlotsCoverTypeChanged.Length - SlotsArrayIndex, 0, 8));
        I = 0;
        J0x85:
        // End:0xFB [Loop If]
        if(I < NumCoverTypesChanged)
        {
            SlotsCoverTypeChanged[I] = CoverReplicationData[Index].SlotsCoverTypeChanged[SlotsArrayIndex + I];
            ++ I;
            // [Loop Continue]
            goto J0x85;
        }
        bDone = (CoverReplicationData[Index].SlotsCoverTypeChanged.Length - SlotsArrayIndex) <= 8;
        ClientReceiveManualCoverTypeSlots(Index, CoverReplicationData[Index].Link, NumCoverTypesChanged, SlotsCoverTypeChanged, bDone);
        SlotsArrayIndex += 8;
        // End:0x37
        if(bDone)
            goto J0x37;
    }
    //return;    
}

reliable client simulated function ClientReceiveManualCoverTypeSlots(int Index, CoverLink Link, byte NumCoverTypesChanged, ManualCoverTypeInfo SlotsCoverTypeChanged[8], bool bDone)
{
    local int I;

    // End:0x32
    if(Link == none)
    {
        // End:0x2F
        if(bDone)
        {
            ServerSendManualCoverTypeSlots(Index);
        }
    }
    // End:0x241
    else
    {
        I = 0;
        J0x3D:
        // End:0x241 [Loop If]
        if(I < NumCoverTypesChanged)
        {
            Link.Slots[SlotsCoverTypeChanged[I].SlotIndex].CoverType = SlotsCoverTypeChanged[I].ManualCoverType;
            // End:0x233
            if((Link.Slots[SlotsCoverTypeChanged[I].SlotIndex].SlotOwner != none) && Link.Slots[SlotsCoverTypeChanged[I].SlotIndex].SlotOwner.Controller != none)
            {
                Link.Slots[SlotsCoverTypeChanged[I].SlotIndex].SlotOwner.Controller.NotifyCoverAdjusted();
            }
            ++ I;
            // [Loop Continue]
            goto J0x3D;
        }
    }
    //return;    
}

function NotifyLinkDisabledStateChange(CoverLink Link)
{
    local int Index;
    local PlayerController PC;

    Index = CoverReplicationData.Find('Link', Link);
    // End:0x98
    if(Index == -1)
    {
        Index = CoverReplicationData.Length;
        CoverReplicationData.Length = CoverReplicationData.Length + 1;
        CoverReplicationData[Index].Link = Link;
    }
    // End:0x18B
    if(WorldInfo.Game.GetCoverReplicator() == self)
    {
        // End:0x18A
        foreach WorldInfo.AllControllers(class'PlayerController', PC)
        {
            // End:0x14C
            if(PC.MyCoverReplicator == none)
            {
                PC.SpawnCoverReplicator();
                // End:0x189
                continue;
            }
            PC.MyCoverReplicator.NotifyLinkDisabledStateChange(Link);            
        }        
    }
    // End:0x1B6
    if(PlayerController(Owner) != none)
    {
        ServerSendLinkDisabledState(Index);
    }
    //return;    
}

reliable server function ServerSendLinkDisabledState(int Index)
{
    // End:0xA1
    if(CoverReplicationData[Index].Link != none)
    {
        ClientReceiveLinkDisabledState(Index, CoverReplicationData[Index].Link, CoverReplicationData[Index].Link.bDisabled);
    }
    //return;    
}

reliable client simulated function ClientReceiveLinkDisabledState(int Index, CoverLink Link, bool bLinkDisabled)
{
    // End:0x25
    if(Link == none)
    {
        ServerSendLinkDisabledState(Index);
    }
    // End:0x4F
    else
    {
        Link.bDisabled = bLinkDisabled;
    }
    //return;    
}

defaultproperties
{
    bOnlyRelevantToOwner=true
    bAlwaysRelevant=false
    NetUpdateFrequency=0.10
}